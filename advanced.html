

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Advanced Topic with Python Channel Access &mdash; Epics Channel Access for Python</title>
    
    <link rel="stylesheet" href="_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '3.2.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="Epics Channel Access for Python" href="index.html" />
    <link rel="prev" title="wx: wxPython Widgets for Epics" href="wx.html" /> 
  </head>
  <body>
<div style="background-color: #E4EAED; text-align: left; padding: 8px 4px 8px 4px">
  <font size=+3><a href="index.html">
      <img src="_static/pyepics.png" height=50 border="0" alt="pyepics"/>
    &nbsp; PyEpics: Epics Channel Access for Python</a>
  </font>
</div>

    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="np-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="wx.html" title="wx: wxPython Widgets for Epics"
             accesskey="P">previous</a> |</li>
   <li><a href="overview.html">overview</a>|</li>
   <li><a href="installation.html">download</a>|</li>
   <li><a href="pv.html">pv</a>|</li>
   <li><a href="ca.html">ca</a>|</li>
   <li><a href="devices.html">devices</a>|</li>
   <li><a href="wx.html">wx</a>|</li>
   <li><a href="#">advanced</a>|</li>
   <li><a href="more.html">contents</a>|</li>
   &nbsp;&nbsp;<li><a href="search.html">search</a></li>
 
      </ul>
    </div>

      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Advanced Topic with Python Channel Access</a><ul>
<li><a class="reference internal" href="#working-with-waveform-array-data">Working with waveform / array data</a><ul>
<li><a class="reference internal" href="#arrays-without-numpy">Arrays without Numpy</a></li>
<li><a class="reference internal" href="#variable-length-arrays">Variable Length Arrays</a></li>
<li><a class="reference internal" href="#character-arrays">Character Arrays</a></li>
</ul>
</li>
<li><a class="reference internal" href="#strategies-for-working-with-large-arrays">Strategies for working with large arrays</a><ul>
<li><a class="reference internal" href="#example-handling-large-arrays">Example handling Large Arrays</a></li>
</ul>
</li>
<li><a class="reference internal" href="#using-python-threads">Using Python Threads</a><ul>
<li><a class="reference internal" href="#channel-access-contexts">Channel Access Contexts</a></li>
<li><a class="reference internal" href="#how-to-work-with-ca-and-threads">How to work with CA and Threads</a></li>
<li><a class="reference internal" href="#thread-examples">Thread Examples</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-wait-and-timeout-options-for-get-ca-get-complete">The wait and timeout options for get(), ca.get_complete()</a></li>
<li><a class="reference internal" href="#strategies-for-connecting-to-a-large-number-of-pvs">Strategies for connecting to a large number of PVs</a></li>
<li><a class="reference internal" href="#time-sleep-or-epics-poll">time.sleep() or epics.poll()?</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="wx.html"
                        title="previous chapter">wx: wxPython Widgets for Epics</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/advanced.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="advanced-topic-with-python-channel-access">
<h1>Advanced Topic with Python Channel Access<a class="headerlink" href="#advanced-topic-with-python-channel-access" title="Permalink to this headline">¶</a></h1>
<p>This chapter contains a variety of &quot;usage notes&quot; and implementation
details that may help in getting the best performance from the
pyepics module.</p>
<div class="section" id="working-with-waveform-array-data">
<span id="advanced-arrays-label"></span><h2>Working with waveform / array data<a class="headerlink" href="#working-with-waveform-array-data" title="Permalink to this headline">¶</a></h2>
<p>Though most EPICS Process Variables hold single values, PVs can hold array
data from EPICS waveform records.  These are always data of homogenous data
type, and have a fixed maximum element count (defined when the waveform is
created from the host EPICS process).  These waveforms are most naturally
mapped to Arrays from the <a class="reference external" href="http://numpy.scipy.org/">numpy module</a>, and
this is strongly encouraged.</p>
<div class="section" id="arrays-without-numpy">
<h3>Arrays without Numpy<a class="headerlink" href="#arrays-without-numpy" title="Permalink to this headline">¶</a></h3>
<p>If you have numpy installed, and use the default <em>as_numpy=True</em> in
<tt class="xref py py-meth docutils literal"><span class="pre">ca.get()</span></tt>, <a class="reference internal" href="pv.html#pv.get" title="pv.get"><tt class="xref py py-meth docutils literal"><span class="pre">pv.get()</span></tt></a> or <a class="reference internal" href="overview.html#epics.caget" title="epics.caget"><tt class="xref py py-meth docutils literal"><span class="pre">epics.caget()</span></tt></a>, you will get a
numpy array for the value of a waveform PV.  If you do <em>not</em> have numpy
installed, or explicitly use <em>as_numpy=False</em> in a get request, you will
get the raw C-like array reference from the Python
<a class="reference external" href="http://docs.python.org/library/ctypes.html#arrays">ctypes module</a>.
These objects are not normally meant for casual use, but are not too
difficult to work with either.  They can be easily converted to a simple
Python list with something like:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">epics</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">epics</span><span class="o">.</span><span class="n">ca</span><span class="o">.</span><span class="n">HAS_NUMPY</span> <span class="o">=</span> <span class="bp">False</span> <span class="c"># turn numpy off for session</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">epics</span><span class="o">.</span><span class="n">PV</span><span class="p">(</span><span class="s">&#39;XX:scan1.P1PA&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
<span class="go">&lt;lib.dbr.c_double_Array_500 object at 0x853980c&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ldat</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">get</span><span class="p">())</span>
</pre></div>
</div>
<p>Note that this conversion to a list can be very slow for large arrays.</p>
</div>
<div class="section" id="variable-length-arrays">
<h3>Variable Length Arrays<a class="headerlink" href="#variable-length-arrays" title="Permalink to this headline">¶</a></h3>
<p>While the maximum length of an array is fixed, the length of data you get
back from a monitor, <tt class="xref py py-meth docutils literal"><span class="pre">ca.get()</span></tt>, <a class="reference internal" href="pv.html#pv.get" title="pv.get"><tt class="xref py py-meth docutils literal"><span class="pre">pv.get()</span></tt></a>, or <a class="reference internal" href="overview.html#epics.caget" title="epics.caget"><tt class="xref py py-meth docutils literal"><span class="pre">epics.caget()</span></tt></a>
may be shorter than the maximumn length, reflecting the most recent data
put to that PV.  That is, if some process puts a smaller array to a PV than
its maximum length, monitors on that PV may receive only the changed data.
For example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">epics</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">epics</span><span class="o">.</span><span class="n">PV</span><span class="p">(</span><span class="s">&#39;Py:double2k&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">p</span>
<span class="go">&lt;PV &#39;Py:double2k&#39;, count=2048/2048, type=double, access=read/write&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="o">/</span><span class="mf">5.0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">p</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
<span class="go">array([ 0. ,  0.2,  0.4,  0.6,  0.8,  1. ,  1.2,  1.4,  1.6,  1.8])</span>
</pre></div>
</div>
<p>To be clear, the <a class="reference internal" href="pv.html#pv.put" title="pv.put"><tt class="xref py py-meth docutils literal"><span class="pre">pv.put()</span></tt></a> above could be done in a separate process
-- the <a class="reference internal" href="pv.html#pv.get" title="pv.get"><tt class="xref py py-meth docutils literal"><span class="pre">pv.get()</span></tt></a> is not using a value cached from the <a class="reference internal" href="pv.html#pv.put" title="pv.put"><tt class="xref py py-meth docutils literal"><span class="pre">pv.put()</span></tt></a>.</p>
<p>This feature seems to depend on the record definition, and requires version
3.14.12.1 of Epics base or higher, and can be checked by comparing
<tt class="xref py py-meth docutils literal"><span class="pre">ca.version()</span></tt> with the string '4.13'.</p>
</div>
<div class="section" id="character-arrays">
<h3>Character Arrays<a class="headerlink" href="#character-arrays" title="Permalink to this headline">¶</a></h3>
<p>As noted in other sections, character waveforms can be used to hold strings
longer than 40 characters, which a fundamental limit for native Epics
strings.    Character waveforms shorter than
<tt class="xref py py-data docutils literal"><span class="pre">ca.AUTOMONITOR_MAXLENGTH</span></tt> can be turned into strings with an optional
<em>as_string=True</em>  to <tt class="xref py py-meth docutils literal"><span class="pre">ca.get()</span></tt>, <a class="reference internal" href="pv.html#pv.get" title="pv.get"><tt class="xref py py-meth docutils literal"><span class="pre">pv.get()</span></tt></a> , or
<a class="reference internal" href="overview.html#epics.caget" title="epics.caget"><tt class="xref py py-meth docutils literal"><span class="pre">epics.caget()</span></tt></a>.   If you've defined a Epics waveform record as:</p>
<div class="highlight-python"><pre>record(waveform,"$(P):filename")  {
          field(DTYP,"Soft Channel")
          field(DESC,"file name")
          field(NELM,"128")
          field(FTVL,"CHAR")
 }</pre>
</div>
<p>Then you can use this record with:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">epics</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pvname</span> <span class="o">=</span> <span class="s">&#39;PREFIX:filename.VAL&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pv</span>  <span class="o">=</span> <span class="n">epics</span><span class="o">.</span><span class="n">PV</span><span class="p">(</span><span class="n">pvname</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">pv</span><span class="o">.</span><span class="n">info</span>
<span class="go">....</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plain_val</span> <span class="o">=</span> <span class="n">pv</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">plain_val</span>
<span class="go">array([ 84,  58,  92, 120,  97, 115,  95, 117, 115, 101, 114,  92,  77,</span>
<span class="go">     97, 114,  99, 104,  50,  48,  49,  48,  92,  70,  97, 115, 116,</span>
<span class="go">     77,  97, 112])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">char_val</span> <span class="o">=</span> <span class="n">pv</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">as_string</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">char_val</span>
<span class="go">&#39;T:\\xas_user\\March2010\\FastMap&#39;</span>
</pre></div>
</div>
<p>This example uses <a class="reference internal" href="pv.html#pv.get" title="pv.get"><tt class="xref py py-meth docutils literal"><span class="pre">pv.get()</span></tt></a> but <tt class="xref py py-meth docutils literal"><span class="pre">ca.get()</span></tt> is essentially
equivalent, as its <em>as_string</em> parameter works exactly the same way.</p>
</div>
</div>
<div class="section" id="strategies-for-working-with-large-arrays">
<span id="advanced-large-arrays-label"></span><h2>Strategies for working with large arrays<a class="headerlink" href="#strategies-for-working-with-large-arrays" title="Permalink to this headline">¶</a></h2>
<p>EPICS Channels / Process Variables usually have values that can be stored
with a small number of bytes.  This means that their storage and transfer
speeds over real networks is not a significant concern.  However, some
Process Variables can store much larger amounts of data (say, several
megabytes) which means that some of the assumptions about dealing with
Channels / PVs may need reconsideration.</p>
<p>When using PVs with large array sizes (here, I'll assert that <em>large</em> means
more than a few thousand elements), it is necessary to make sure that the
environmental variable <tt class="docutils literal"><span class="pre">EPICS_CA_MAX_ARRAY_BYTES</span></tt> is suitably set.
Unfortunately, this represents a pretty crude approach to memory management
within Epics for handling array data as it is used not only sets how large
an array the client can accept, but how much memory will be allocated on
the server.  In addition, this value must be set prior to using the CA
library -- it cannot be altered during the running of a CA program.</p>
<p>Normally, the default value for <tt class="docutils literal"><span class="pre">EPICS_CA_MAX_ARRAY_BYTES</span></tt> is 16384 (16k,
and it turns out that you cannot set it smaller than this value!).  As
Python is used for clients, generally running on workstations or servers
with sufficient memory, this default value is changed to 2**24, or 16Mb)
when <a class="reference internal" href="ca.html#module-epics.ca" title="epics.ca: low-level Channel Access  module."><tt class="xref py py-mod docutils literal"><span class="pre">epics.ca</span></tt></a> is initialized.  If the environmental variable
<tt class="docutils literal"><span class="pre">EPICS_CA_MAX_ARRAY_BYTES</span></tt> has not already been set.</p>
<p>The other main issue for PVs holding large arrays is whether they should be
automatically monitored.  For PVs holding scalar data or small arrays, any
penalty for automatically monitoring these variables (that is, causing
network traffic every time a PV changes) is a small price to pay for being
assured that the latest value is always available.  As arrays get larger
(as for data streams from Area Detectors), it is less obvious that
automatic monitoring is desirable.</p>
<p>The Python <a class="reference internal" href="ca.html#module-epics.ca" title="epics.ca: low-level Channel Access  module."><tt class="xref py py-mod docutils literal"><span class="pre">epics.ca</span></tt></a> module defines a variable
<tt class="xref py py-data docutils literal"><span class="pre">ca.AUTOMONITOR_MAXLENGTH</span></tt> which controls whether array PVs are
automatically monitored.  The default value for this variable is 65536, but
can be changed at runtime.  Arrays with fewer elements than
<tt class="xref py py-data docutils literal"><span class="pre">ca.AUTOMONITOR_MAXLENGTH</span></tt> will be automatically monitored, unless
explicitly set, and arrays larger than <tt class="xref py py-data docutils literal"><span class="pre">AUTOMONITOR_MAXLENGTH</span></tt> will
not be automatically monitored unless explicitly set. Auto-monitoring of
PVs can be be explicitly set with</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">pv2</span> <span class="o">=</span> <span class="n">epics</span><span class="o">.</span><span class="n">PV</span><span class="p">(</span><span class="s">&#39;ScalerPV&#39;</span><span class="p">,</span> <span class="n">auto_monitor</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pv1</span> <span class="o">=</span> <span class="n">epics</span><span class="o">.</span><span class="n">PV</span><span class="p">(</span><span class="s">&#39;LargeArrayPV&#39;</span><span class="p">,</span> <span class="n">auto_monitor</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
</pre></div>
</div>
<div class="section" id="example-handling-large-arrays">
<h3>Example handling Large Arrays<a class="headerlink" href="#example-handling-large-arrays" title="Permalink to this headline">¶</a></h3>
<p>Here is an example reading data from an <a class="reference external" href="http://cars9.uchicago.edu/software/epics/areaDetector.html">EPICS areaDetector</a>, as if it
were an image from a digital camera.  This uses the <a class="reference external" href="http://www.pythonware.com/products/pil/">Python Imaging Library</a> for much of the image
processing:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">epics</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">Image</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pvname</span> <span class="o">=</span> <span class="s">&#39;13IDCPS1:image1:ArrayData&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img_pv</span>  <span class="o">=</span> <span class="n">epics</span><span class="o">.</span><span class="n">PV</span><span class="p">(</span><span class="n">pvname</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">raw_image</span> <span class="o">=</span> <span class="n">img_pv</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im_mode</span> <span class="o">=</span> <span class="s">&#39;RGB&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im_size</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1360</span><span class="p">,</span> <span class="mi">1024</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">Image</span><span class="o">.</span><span class="n">frombuffer</span><span class="p">(</span><span class="n">im_mode</span><span class="p">,</span> <span class="n">im_size</span><span class="p">,</span> <span class="n">raw_image</span><span class="p">,</span>
<span class="go">                            &#39;raw&#39;, im_mode, 0, 1)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>The result looks like this (taken with a Prosilica GigE camera):</p>
<img alt="_images/AreaDetector1.png" src="_images/AreaDetector1.png" />
<p>A more complete application for reading and displaying image from Epics
Area Detectors is included  at <a class="reference external" href="http://github.com/pyepics/epicsapps/">http://github.com/pyepics/epicsapps/</a>.</p>
</div>
</div>
<div class="section" id="using-python-threads">
<span id="advanced-threads-label"></span><h2>Using Python Threads<a class="headerlink" href="#using-python-threads" title="Permalink to this headline">¶</a></h2>
<p>An important feature of the PyEpics package is that it can be used with
Python threads, as Epics 3.14 supports threads for client code.  Even in
the best of cases, working with threads can be somewhat tricky and lead to
unexpected behavior, and the Channel Access library adds a small level of
complication for using CA with Python threads.  The result is that some
precautions may be in order when using PyEpics and threads.  This section
discusses the strategies for using threads with PyEpics.</p>
<p>First, to use threads with Channel Access, you must have
<a class="reference internal" href="ca.html#epics.ca.PREEMPTIVE_CALLBACK" title="epics.ca.PREEMPTIVE_CALLBACK"><tt class="xref py py-data docutils literal"><span class="pre">epics.ca.PREEMPTIVE_CALLBACK</span></tt></a> = <tt class="docutils literal"><span class="pre">True</span></tt>.  This is the default
value, but if <a class="reference internal" href="ca.html#epics.ca.PREEMPTIVE_CALLBACK" title="epics.ca.PREEMPTIVE_CALLBACK"><tt class="xref py py-data docutils literal"><span class="pre">epics.ca.PREEMPTIVE_CALLBACK</span></tt></a> has been set to
<tt class="docutils literal"><span class="pre">False</span></tt>, threading will not work.</p>
<p>Second, if you are using <tt class="xref py py-class docutils literal"><span class="pre">PV</span></tt> objects and not making heavy use of
the <a class="reference internal" href="ca.html#module-ca" title="ca: low-level Channel Access  module."><tt class="xref py py-mod docutils literal"><span class="pre">ca</span></tt></a> module (that is, not making and passing around chids), then
the complications below are mostly hidden from you.   If you're writing
threaded code, it's probably a good idea to read this just to understand
what the issues are.</p>
<div class="section" id="channel-access-contexts">
<h3>Channel Access Contexts<a class="headerlink" href="#channel-access-contexts" title="Permalink to this headline">¶</a></h3>
<p>The Channel Access library uses a concept of <em>contexts</em> for its own thread
model, with contexts holding sets of threads as well as Channels and
Process Variables.  For non-threaded work, a process will use a single
context that is initialized prior doing any real CA work (done in
<tt class="xref py py-meth docutils literal"><span class="pre">ca.initialize_libca()</span></tt>).  In a threaded application, each new thread
begins with a new, uninitialized context that must be initialized or
replaced.  Thus each new python thread that will interact with CA must
either explicitly create its own context with <tt class="xref py py-meth docutils literal"><span class="pre">ca.create_context()</span></tt>
(and then, being a good citizen, destroy this context as the thread ends
with <tt class="xref py py-meth docutils literal"><span class="pre">ca.destroy_context()</span></tt>) or attach to an existing context.</p>
<p>The generally recommended approach is to use a single CA context throughout
an entire process and have each thread attach to the first context created
(probably from the main thread).  This avoids many potential pitfalls (and
crashes), and can be done fairly simply.  It is the default mode when using
PV objects.</p>
<p>The most explicit use of contexts is to put <a class="reference internal" href="ca.html#epics.ca.create_context" title="epics.ca.create_context"><tt class="xref py py-func docutils literal"><span class="pre">epics.ca.create_context()</span></tt></a>
at the start of each function call as a thread target, and
<a class="reference internal" href="ca.html#epics.ca.destroy_context" title="epics.ca.destroy_context"><tt class="xref py py-func docutils literal"><span class="pre">epics.ca.destroy_context()</span></tt></a> at the end of each thread.  This will
cause all the activity in that thread to be done in its own context.  This
works, but means more care is needed, and so is not the recommended.</p>
<p>The best way to attach to the initially created context is to call
<a class="reference internal" href="ca.html#epics.ca.use_initial_context" title="epics.ca.use_initial_context"><tt class="xref py py-meth docutils literal"><span class="pre">epics.ca.use_initial_context()</span></tt></a> before any other CA calls in each
function that will be called by <tt class="xref py py-meth docutils literal"><span class="pre">Thread.run()</span></tt>.  Equivalently, you can
add a <tt class="xref py py-func docutils literal"><span class="pre">withInitialContext()</span></tt> decorator to the function.  Creating a PV
object will implicitly do this for you, as long as it is your first CA
action in the function.  Each time you do a <tt class="xref py py-meth docutils literal"><span class="pre">PV.get()</span></tt> or
<tt class="xref py py-meth docutils literal"><span class="pre">PV.put()</span></tt> (or a few other methods), it will also check that the initial
context is being used.</p>
<p>Of course, this approach requires CA to be initialized already.  Doing that
<em>in the main thread</em> is highly recommended.  If it happens in a child
thread, that thread must exist for all CA work, so either the life of the
process or with great care for processes that do only some CA calls.  If
you are writing a threaded application in which the first real CA calls are
inside a child thread, it is recommended that you initialize CA in the main
thread,</p>
<p>As a convenience, the <tt class="xref py py-class docutils literal"><span class="pre">CAThread</span></tt> in the <a class="reference internal" href="ca.html#module-ca" title="ca: low-level Channel Access  module."><tt class="xref py py-mod docutils literal"><span class="pre">ca</span></tt></a> module is
is a very thin wrapper around the standard <tt class="xref py py-class docutils literal"><span class="pre">threading.Thread</span></tt> which
adding a call of  <a class="reference internal" href="ca.html#epics.ca.use_initial_context" title="epics.ca.use_initial_context"><tt class="xref py py-meth docutils literal"><span class="pre">epics.ca.use_initial_context()</span></tt></a> just before your
threaded function is run.  This allows your target functions to not
explicitly set the context, but still ensures that the initial context is
used in all functions.</p>
</div>
<div class="section" id="how-to-work-with-ca-and-threads">
<h3>How to work with CA and Threads<a class="headerlink" href="#how-to-work-with-ca-and-threads" title="Permalink to this headline">¶</a></h3>
<p>Summarizing the discussion above, to use threads you must use run in
PREEMPTIVE_CALLBACK mode.  Furthermore, it is recommended that you use a
single context, and that you initialize CA in the main program thread so
that your single CA context belongs to the main thread.  Using PV objects
exclusively makes this easy, but it can also be accomplished relatively
easily using the lower-level ca interface.  The options for using threads
(in approximate order of reliability) are then:</p>
<blockquote>
<div><ol class="arabic simple">
<li>use PV objects for threading work.</li>
</ol>
<p>2. use <tt class="xref py py-class docutils literal"><span class="pre">CAThread</span></tt> instead of <tt class="xref py py-class docutils literal"><span class="pre">Thread</span></tt> for threads that
will use CA calls.</p>
<p>3. put <a class="reference internal" href="ca.html#epics.ca.use_initial_context" title="epics.ca.use_initial_context"><tt class="xref py py-func docutils literal"><span class="pre">epics.ca.use_initial_context()</span></tt></a> at the top of all
functions that might be a Thread target function, or decorate them with
<tt class="xref py py-func docutils literal"><span class="pre">withInitialContext()</span></tt> decorator, <em>&#64;withInitialContext</em>.</p>
<p>4. use <a class="reference internal" href="ca.html#epics.ca.create_context" title="epics.ca.create_context"><tt class="xref py py-func docutils literal"><span class="pre">epics.ca.create_context()</span></tt></a> at the top of all functions
that are inside a new thread, and be sure to put
<a class="reference internal" href="ca.html#epics.ca.destroy_context" title="epics.ca.destroy_context"><tt class="xref py py-func docutils literal"><span class="pre">epics.ca.destroy_context()</span></tt></a> at the end of the function.</p>
<p>5. ignore this advise and hope for the best.  If you're not creating
new PVs and only reading values of PVs created in the main thread
inside a child thread, you may not see a problems, at least not until
you try to do something fancier.</p>
</div></blockquote>
</div>
<div class="section" id="thread-examples">
<h3>Thread Examples<a class="headerlink" href="#thread-examples" title="Permalink to this headline">¶</a></h3>
<p>This is a simplified version of test code using Python threads.  It is
based on code originally from Friedrich Schotte, NIH, and included as
<cite>thread_test.py</cite> in the <cite>tests</cite> directory of the source distribution.</p>
<p>In this example, we define a <cite>run_test</cite> procedure which will create PVs
from a supplied list, and monitor these PVs, printing out the values when
they change.  Two threads are created and run concurrently, with
overlapping PV lists, though one thread is run for a shorter time than the
other.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="sd">&quot;&quot;&quot;This script tests using EPICS CA and Python threads together</span>
<span class="sd">Based on code from  Friedrich Schotte, NIH, modified by Matt Newville</span>
<span class="sd">19-Apr-2010</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">from</span>  <span class="nn">sys</span> <span class="kn">import</span> <span class="n">stdout</span>
<span class="kn">from</span> <span class="nn">threading</span> <span class="kn">import</span> <span class="n">Thread</span>
<span class="kn">import</span> <span class="nn">epics</span>

<span class="kn">from</span>  <span class="nn">pvnames</span> <span class="kn">import</span> <span class="n">updating_pvlist</span>
<span class="n">pvlist_a</span> <span class="o">=</span> <span class="n">updating_pvlist</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="n">pvlist_b</span> <span class="o">=</span> <span class="n">updating_pvlist</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>

<span class="k">def</span> <span class="nf">run_test</span><span class="p">(</span><span class="n">runtime</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">pvnames</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>  <span class="n">run_name</span><span class="o">=</span><span class="s">&#39;thread c&#39;</span><span class="p">):</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="s">&#39;-&gt; thread &quot;</span><span class="si">%s</span><span class="s">&quot; will run for </span><span class="si">%.3f</span><span class="s"> sec, monitoring </span><span class="si">%s</span><span class="se">\n</span><span class="s">&#39;</span>
    <span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">msg</span> <span class="o">%</span> <span class="p">(</span><span class="n">run_name</span><span class="p">,</span> <span class="n">runtime</span><span class="p">,</span> <span class="n">pvnames</span><span class="p">))</span>
    <span class="k">def</span> <span class="nf">onChanges</span><span class="p">(</span><span class="n">pvname</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">char_value</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;   </span><span class="si">%s</span><span class="s"> = </span><span class="si">%s</span><span class="s"> (</span><span class="si">%s</span><span class="s">)</span><span class="se">\n</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">pvname</span><span class="p">,</span> <span class="n">char_value</span><span class="p">,</span> <span class="n">run_name</span><span class="p">))</span>
        <span class="n">stdout</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>

    <span class="c"># epics.ca.use_initial_context()   #  epics.ca.create_context()</span>
    <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">pvs</span> <span class="o">=</span> <span class="p">[</span><span class="n">epics</span><span class="o">.</span><span class="n">PV</span><span class="p">(</span><span class="n">pvn</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="n">onChanges</span><span class="p">)</span> <span class="k">for</span> <span class="n">pvn</span> <span class="ow">in</span> <span class="n">pvnames</span><span class="p">]</span>

    <span class="k">while</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">start_time</span> <span class="o">&lt;</span> <span class="n">runtime</span><span class="p">:</span>
        <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span>

    <span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">clear_callbacks</span><span class="p">()</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">pvs</span><span class="p">]</span>
    <span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span> <span class="s">&#39;Completed Thread  </span><span class="si">%s</span><span class="se">\n</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span> <span class="n">run_name</span><span class="p">))</span>

<span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span> <span class="s">&quot;First, create a PV in the main thread:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">)</span>
<span class="n">p</span> <span class="o">=</span> <span class="n">epics</span><span class="o">.</span><span class="n">PV</span><span class="p">(</span><span class="n">updating_pvlist</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

<span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&quot;Run 2 Background Threads simultaneously:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">)</span>
<span class="n">th1</span> <span class="o">=</span> <span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">run_test</span><span class="p">,</span><span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">pvlist_a</span><span class="p">,</span>  <span class="s">&#39;A&#39;</span><span class="p">))</span>
<span class="n">th1</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>

<span class="n">th2</span> <span class="o">=</span> <span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">run_test</span><span class="p">,</span><span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="n">pvlist_b</span><span class="p">,</span> <span class="s">&#39;B&#39;</span><span class="p">))</span>
<span class="n">th2</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>

<span class="n">th2</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
<span class="n">th1</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
<span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;Done</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>In light of the long discussion above, a few remarks are in order: This
code uses the standard Thread library and explicitly calls
<a class="reference internal" href="ca.html#epics.ca.use_initial_context" title="epics.ca.use_initial_context"><tt class="xref py py-func docutils literal"><span class="pre">epics.ca.use_initial_context()</span></tt></a> prior to any CA calls in the target
function.  Also note that the <tt class="xref py py-func docutils literal"><span class="pre">run_test()</span></tt> function is first called
from the main thread, so that the initial CA context does belong to the
main thread.  Finally, the <a class="reference internal" href="ca.html#epics.ca.use_initial_context" title="epics.ca.use_initial_context"><tt class="xref py py-func docutils literal"><span class="pre">epics.ca.use_initial_context()</span></tt></a> call in
<tt class="xref py py-func docutils literal"><span class="pre">run_test()</span></tt> above could be replaced with
<a class="reference internal" href="ca.html#epics.ca.create_context" title="epics.ca.create_context"><tt class="xref py py-func docutils literal"><span class="pre">epics.ca.create_context()</span></tt></a>, and run OK.</p>
<p>The output from this will look like:</p>
<div class="highlight-python"><pre>First, create a PV in the main thread:
Run 2 Background Threads simultaneously:
-&gt; thread "A" will run for 3.000 sec, monitoring ['Py:ao1', 'Py:ai1', 'Py:long1']
-&gt; thread "B" will run for 6.000 sec, monitoring ['Py:ai1', 'Py:long1', 'Py:ao2']
   Py:ao1 = 8.3948 (A)
   Py:ai1 = 3.14 (B)
   Py:ai1 = 3.14 (A)
   Py:ao1 = 0.7404 (A)
   Py:ai1 = 4.07 (B)
   Py:ai1 = 4.07 (A)
   Py:long1 = 3 (B)
   Py:long1 = 3 (A)
   Py:ao1 = 13.0861 (A)
   Py:ai1 = 8.49 (B)
   Py:ai1 = 8.49 (A)
   Py:ao2 = 30 (B)
Completed Thread  A
   Py:ai1 = 9.42 (B)
   Py:ao2 = 30 (B)
   Py:long1 = 4 (B)
   Py:ai1 = 3.35 (B)
   Py:ao2 = 31 (B)
   Py:ai1 = 4.27 (B)
   Py:ao2 = 31 (B)
   Py:long1 = 5 (B)
   Py:ai1 = 8.20 (B)
   Py:ao2 = 31 (B)
Completed Thread  B
Done</pre>
</div>
<p>Note that while both threads <em>A</em> and <em>B</em> are running, a callback for the
PV <cite>Py:ai1</cite> is generated in each thread.</p>
<p>Note also that the callbacks for the PVs created in each thread are
<strong>explicitly cleared</strong>  with:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">clear_callbacks</span><span class="p">()</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">pvs</span><span class="p">]</span>
</pre></div>
</div>
<p>Without this, the callbacks for thread <em>A</em>  will persist even after the
thread has completed!</p>
</div>
</div>
<div class="section" id="the-wait-and-timeout-options-for-get-ca-get-complete">
<span id="advanced-get-timeouts-label"></span><h2>The wait and timeout options for get(), ca.get_complete()<a class="headerlink" href="#the-wait-and-timeout-options-for-get-ca-get-complete" title="Permalink to this headline">¶</a></h2>
<p>The <em>get</em> functions, <a class="reference internal" href="overview.html#epics.caget" title="epics.caget"><tt class="xref py py-func docutils literal"><span class="pre">epics.caget()</span></tt></a>, <a class="reference internal" href="pv.html#pv.get" title="pv.get"><tt class="xref py py-func docutils literal"><span class="pre">pv.get()</span></tt></a> and <tt class="xref py py-func docutils literal"><span class="pre">ca.get()</span></tt>
all ask for data to be transferred over the network.  For large data arrays
or slow networks, this can can take a noticeable amount of time.  For PVs
that have been disconnected, the <em>get</em> call will fail to return a value at
all.  For this reason, these functions all take a <cite>timeout</cite> keyword option.
The lowest level <tt class="xref py py-func docutils literal"><span class="pre">ca.get()</span></tt> also has a <cite>wait</cite> option, and a companion
function <tt class="xref py py-func docutils literal"><span class="pre">ca.get_complete()</span></tt>.  This section describes the details of
these.</p>
<p>If you're using <a class="reference internal" href="overview.html#epics.caget" title="epics.caget"><tt class="xref py py-func docutils literal"><span class="pre">epics.caget()</span></tt></a> or <a class="reference internal" href="pv.html#pv.get" title="pv.get"><tt class="xref py py-func docutils literal"><span class="pre">pv.get()</span></tt></a> you can supply a
timeout value.  If the value returned is <tt class="docutils literal"><span class="pre">None</span></tt>, then either the PV has
truly disconnected or the timeout passed before receiving the value.  If
the <em>get</em> is incomplete, in that the PV is connected but the data has
simply not been received yet, a subsequent <a class="reference internal" href="overview.html#epics.caget" title="epics.caget"><tt class="xref py py-func docutils literal"><span class="pre">epics.caget()</span></tt></a> or
<a class="reference internal" href="pv.html#pv.get" title="pv.get"><tt class="xref py py-func docutils literal"><span class="pre">pv.get()</span></tt></a> will eventually complete and receive the value.  That is, if
a PV for a large waveform record reports that it is connected, but a
<a class="reference internal" href="pv.html#pv.get" title="pv.get"><tt class="xref py py-func docutils literal"><span class="pre">pv.get()</span></tt></a> returns None, simply trying again later will probably work:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">epics</span><span class="o">.</span><span class="n">PV</span><span class="p">(</span><span class="s">&#39;LargeWaveform&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">val</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">val</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">val</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
</pre></div>
</div>
<p>At the lowest level (which <a class="reference internal" href="pv.html#pv.get" title="pv.get"><tt class="xref py py-func docutils literal"><span class="pre">pv.get()</span></tt></a> and <a class="reference internal" href="overview.html#epics.caget" title="epics.caget"><tt class="xref py py-func docutils literal"><span class="pre">epics.caget()</span></tt></a> use),
<tt class="xref py py-func docutils literal"><span class="pre">ca.get()</span></tt> issues a get-request with an internal callback function.
That is, it calls the CA library function
<tt class="xref py py-func docutils literal"><span class="pre">libca.ca_array_get_callback()</span></tt> with a pre-defined callback function.
With <cite>wait=True</cite> (the default), <tt class="xref py py-func docutils literal"><span class="pre">ca.get()</span></tt> then waits up to the timeout
or until the CA library calls the specified callback function.  If the
callback has been called, the value can then be converted and returned.</p>
<p>If the callback is not called in time or if <cite>wait=False</cite> is used but the PV
is connected, the callback will be called eventually, and simply waiting
(or using <tt class="xref py py-func docutils literal"><span class="pre">ca.pend_event()</span></tt> if <tt class="xref py py-data docutils literal"><span class="pre">ca.PREEMPTIVE_CALLBACK</span></tt> is
<tt class="docutils literal"><span class="pre">False</span></tt>) may be sufficient for the data to arrive.  Under this condition,
you can call <tt class="xref py py-func docutils literal"><span class="pre">ca.get_complete()</span></tt>, which will NOT issue a new request
for data to be sent, but wait (for up to a timeout time) for the previous
get request to complete.</p>
<p><tt class="xref py py-func docutils literal"><span class="pre">ca.get_complete()</span></tt> will return <tt class="docutils literal"><span class="pre">None</span></tt> if the timeout is exceeded or
if there is not an &quot;incomplete get&quot; that it can wait to complete.  Thus,
you should use the return value from <tt class="xref py py-func docutils literal"><span class="pre">ca.get_complete()</span></tt> with care.</p>
<p>Note that <a class="reference internal" href="pv.html#pv.get" title="pv.get"><tt class="xref py py-func docutils literal"><span class="pre">pv.get()</span></tt></a> (and so <a class="reference internal" href="overview.html#epics.caget" title="epics.caget"><tt class="xref py py-func docutils literal"><span class="pre">epics.caget()</span></tt></a>) will normally rely on
the PV value to be filled in automatically by monitor callbacks.  If
monitor callbacks are disabled (as is done for large arrays and can be
turned off) or if the monitor hasn't been called yet, <a class="reference internal" href="pv.html#pv.get" title="pv.get"><tt class="xref py py-func docutils literal"><span class="pre">pv.get()</span></tt></a> will
check whether it should can <tt class="xref py py-func docutils literal"><span class="pre">ca.get()</span></tt> or <tt class="xref py py-func docutils literal"><span class="pre">ca.get_complete()</span></tt>.</p>
<p>If not specified, the timeout for <tt class="xref py py-func docutils literal"><span class="pre">ca.get_complete()</span></tt> (and all other
get functions) will be set to:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">timeout</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">+</span> <span class="n">log10</span><span class="p">(</span><span class="n">count</span><span class="p">)</span>
</pre></div>
</div>
<p>Again, that's the maximum time that will be waited, and if the data is
received faster than that, the <em>get</em> will return as soon as it can.</p>
</div>
<div class="section" id="strategies-for-connecting-to-a-large-number-of-pvs">
<span id="advanced-connecting-many-label"></span><h2>Strategies for connecting to a large number of PVs<a class="headerlink" href="#strategies-for-connecting-to-a-large-number-of-pvs" title="Permalink to this headline">¶</a></h2>
<p>Occasionally, you may find that you need to quickly connect to a large
number of PVs, say to write values to disk.  The most straightforward way
to do this, say:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">epics</span>

<span class="n">pvnamelist</span> <span class="o">=</span> <span class="n">read_list_pvs</span><span class="p">()</span>
<span class="n">pv_vals</span> <span class="o">=</span> <span class="p">{}</span>
<span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">pvnamelist</span><span class="p">:</span>
    <span class="n">pv</span> <span class="o">=</span> <span class="n">epics</span><span class="o">.</span><span class="n">PV</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
    <span class="n">pv_vals</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">pv</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
</pre></div>
</div>
<p>does incur some small performance penalty.  As shown below, the penalty
is generally pretty small in absolute terms, but can be noticeable when
you are connecting to a large number (say, more than 100) PVs at once.</p>
<p>The cause for the penalty, and its remedy, are two-fold.  First, a <cite>PV</cite>
object automatically use connection and event callbacks.  Normally, these
are advantages, as you don't need to explicitly deal with them.  But,
internally, they do pause for network responses using <tt class="xref py py-meth docutils literal"><span class="pre">ca.pend_event()</span></tt>
and these pauses can add up.  Second, the <tt class="xref py py-meth docutils literal"><span class="pre">ca.get()</span></tt> also pauses for
network response, so that the returned value actually contains the latest
data right away, as discussed in the previous section.</p>
<dl class="docutils">
<dt>The remedies are to</dt>
<dd><ol class="first last arabic simple">
<li>not use connection or event callbacks.</li>
<li>not explicitly wait for values to be returned for each <tt class="xref py py-meth docutils literal"><span class="pre">get()</span></tt>.</li>
</ol>
</dd>
</dl>
<p>A more complicated but faster approach relies on a carefully-tuned use of
the CA library, and would be the following:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">epics</span> <span class="kn">import</span> <span class="n">ca</span>

<span class="n">pvnamelist</span> <span class="o">=</span> <span class="n">read_list_pvs</span><span class="p">()</span>

<span class="n">pvdata</span> <span class="o">=</span> <span class="p">{}</span>
<span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">pvnamelist</span><span class="p">:</span>
    <span class="n">chid</span> <span class="o">=</span> <span class="n">ca</span><span class="o">.</span><span class="n">create_channel</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">connect</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">auto_cb</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span> <span class="c"># note 1</span>
    <span class="n">pvdata</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">chid</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>

<span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">data</span> <span class="ow">in</span> <span class="n">pvdata</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
    <span class="n">ca</span><span class="o">.</span><span class="n">connect_channel</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="n">ca</span><span class="o">.</span><span class="n">poll</span><span class="p">()</span>
<span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">data</span> <span class="ow">in</span> <span class="n">pvdata</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
    <span class="n">ca</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">wait</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>  <span class="c"># note 2</span>

<span class="n">ca</span><span class="o">.</span><span class="n">poll</span><span class="p">()</span>
<span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">data</span> <span class="ow">in</span> <span class="n">pvdata</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
    <span class="n">val</span> <span class="o">=</span> <span class="n">ca</span><span class="o">.</span><span class="n">get_complete</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">pvdata</span><span class="p">[</span><span class="n">name</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>

<span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">data</span> <span class="ow">in</span> <span class="n">pvdata</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
    <span class="k">print</span> <span class="n">name</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>
<p>The code here probably needs detailed explanation.  The first thing to
notice is that this is using the <cite>ca</cite> level, not <cite>PV</cite> objects.  Second
(Note 1), the <cite>connect=False</cite> and <cite>auto_cb=False</cite> options to
<tt class="xref py py-meth docutils literal"><span class="pre">ca.create_channel()</span></tt>.  These respectively tell
<tt class="xref py py-meth docutils literal"><span class="pre">ca.create_channel()</span></tt> to not wait for a connection before returning,
and to not automatically assign a connection callback.  Normally, these are
not what you want, as you want a connected channel and to know if the
connection state changes.  But we're aiming for maximum speed here, so we
avoid these.</p>
<p>We then explicitly call <tt class="xref py py-meth docutils literal"><span class="pre">ca.connect_channel()</span></tt> for all the channels.
Next (Note 2), we tell the CA library to request the data for the channel
without waiting around to receive it.  The main point of not having
<tt class="xref py py-meth docutils literal"><span class="pre">ca.get()</span></tt> wait for the data for each channel as we go is that each
data transfer takes time.  Instead we request data to be sent in a separate
thread for all channels without waiting.  Then we do wait by calling
<tt class="xref py py-meth docutils literal"><span class="pre">ca.poll()</span></tt> once and only once, (not len(channels) times!).  Finally,
we use the <tt class="xref py py-meth docutils literal"><span class="pre">ca.get_complete()</span></tt> method to convert the data that has now
been received by the companion thread to a python value.</p>
<p>How much faster is the more explicit method?  In my tests, I used 20,000
PVs, all scalar values, all actually connected, and all on the same subnet
as the test client, though on a mixture of several vxWorks and linux IOCs.
I found that the simplest, obvious approach as above took around 12 seconds
to read all 20,000 PVs.  Using the <cite>ca</cite> layer with connection callbacks and
a normal call to <tt class="xref py py-meth docutils literal"><span class="pre">ca.get()</span></tt> also took about 12 seconds.  The method
without connection callbacks and with delayed unpacking above took about 2
seconds to read all 20,000 PVs.</p>
<p>Is that performance boost from 12 to 2 seconds significant?  If you're
writing a script that is intended to run once, fetch a large number of PVs
and get their values (say, an auto-save script that runs on demand), then
the boost is definitely significant.  On the other hand, if you're writing
a long running process or a process that will retain the PV connections and
get their values multiple times, the difference in start-up speed is less
significant.  For a long running auto-save script that periodically writes
out all the PV values, the &quot;obvious&quot; way using automatically monitored PVs
may be much <em>better</em>, as the time for the initial connection is small, and
the use of event callbacks will reduce network traffic for PVs that don't
change between writes.</p>
<p>Note that the tests also show that, with the simplest approach, 1,000 PVs
should connect and receive values in under 1 second.  Any application that
is sure it needs to connect to PVs faster than that rate will want to do
careful timing tests.  Finally, note also that the issues are not really a
classic <em>python is slow compared to C</em> issue, but rather a matter of how
much pausing with <tt class="xref py py-meth docutils literal"><span class="pre">ca.poll()</span></tt> one does to make sure values are
immediately useful.</p>
</div>
<div class="section" id="time-sleep-or-epics-poll">
<span id="advanced-sleep-label"></span><h2>time.sleep() or epics.poll()?<a class="headerlink" href="#time-sleep-or-epics-poll" title="Permalink to this headline">¶</a></h2>
<p>In order for a program to communicate with Epics devices, it needs to allow
some time for this communication to happen.   With
<tt class="xref py py-data docutils literal"><span class="pre">ca.PREEMPTIVE_CALLBACK</span></tt> set to  <tt class="docutils literal"><span class="pre">True</span></tt>, this communication  will
be handled in a thread separate from the main Python thread.  This means
that CA events can happen at any time, and <tt class="xref py py-meth docutils literal"><span class="pre">ca.pend_event()</span></tt> does not
need to be called to explicitly allow for event processing.</p>
<p>Still, some time must be released from the main Python thread on occasion
in order for events to be processed.  The simplest way to do this is with
<tt class="xref py py-meth docutils literal"><span class="pre">time.sleep()</span></tt>, so that an event loop can simply be:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.001</span><span class="p">)</span>
</pre></div>
</div>
<p>Unfortunately, the <tt class="xref py py-meth docutils literal"><span class="pre">time.sleep()</span></tt> method is not a very high-resolution
clock, with typical resolutions of 1 to 10 ms, depending on the system.
Thus, even though events will be asynchronously generated and epics with
pre-emptive callbacks does not <em>require</em> <tt class="xref py py-meth docutils literal"><span class="pre">ca.pend_event()</span></tt> or
<tt class="xref py py-meth docutils literal"><span class="pre">ca.poll()</span></tt> to be run, better performance may be achieved with an event
loop of:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">epics</span><span class="o">.</span><span class="n">poll</span><span class="p">(</span><span class="n">evt</span><span class="o">=</span><span class="mf">1.e-5</span><span class="p">,</span> <span class="n">iot</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>
</pre></div>
</div>
<p>as the loop will be run more often than using <tt class="xref py py-meth docutils literal"><span class="pre">time.sleep()</span></tt>.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="np-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="wx.html" title="wx: wxPython Widgets for Epics"
             >previous</a> |</li>
   <li><a href="overview.html">overview</a>|</li>
   <li><a href="installation.html">download</a>|</li>
   <li><a href="pv.html">pv</a>|</li>
   <li><a href="ca.html">ca</a>|</li>
   <li><a href="devices.html">devices</a>|</li>
   <li><a href="wx.html">wx</a>|</li>
   <li><a href="#">advanced</a>|</li>
   <li><a href="more.html">contents</a>|</li>
   &nbsp;&nbsp;<li><a href="search.html">search</a></li>
 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2012, Matthew Newville.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>