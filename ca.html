

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>epics.ca Low-Level Epics Interface &mdash; Epics Channel Access for Python</title>
    <link rel="stylesheet" href="_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '3.1.4',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="Epics Channel Access for Python" href="index.html" />
    <link rel="next" title="Advanced Topic with Python Channel Access" href="advanced.html" />
    <link rel="prev" title="The Epics PV class" href="pv.html" /> 
  </head>
  <body>
<div style="background-color: #E4EAED; text-align: left; padding: 0px 0px 15px 15px">
 <h1> <a href="index.html">PyEpics: Epics Channel Access for Python</a></h1>
</div>

    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="advanced.html" title="Advanced Topic with Python Channel Access"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="pv.html" title="The Epics PV class"
             accesskey="P">previous</a> |</li>
   <li><a href="overview.html">getting started</a>|&nbsp;</li>
   <li><a href="installation.html">download</a>|&nbsp;</li>
   <li><a href="pv.html">PVs</a>|&nbsp;</li>
   <li><a href="devices.html">Devices</a>|&nbsp;</li>
   <li><a href="wx.html">wxWidgets</a>|&nbsp;</li>
   <li><a href="more.html">More...</a>|&nbsp;</li>
   &nbsp;&nbsp;<li><a href="search.html">search</a>&nbsp;</li>
 
      </ul>
    </div>

      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#"><tt class="docutils literal"><span class="pre">epics.ca</span></tt> Low-Level Epics Interface</a><ul>
<li><a class="reference internal" href="#general-description-difference-with-c-library">General description, difference with C library</a><ul>
<li><a class="reference internal" href="#name-mangling">Name Mangling</a></li>
<li><a class="reference internal" href="#other-changes-and-omissions">Other Changes and Omissions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-ca">Initialization, Finalization, and Life-cycle</a></li>
<li><a class="reference internal" href="#using-the-ca-module">Using the CA module</a><ul>
<li><a class="reference internal" href="#creating-and-connecting-to-channels">Creating and Connecting to Channels</a></li>
<li><a class="reference internal" href="#interacting-with-connected-channels">Interacting with Connected Channels</a></li>
<li><a class="reference internal" href="#synchronous-groups">Synchronous Groups</a></li>
</ul>
</li>
<li><a class="reference internal" href="#implementation-details">Implementation details</a><ul>
<li><a class="reference internal" href="#dbr-data-types">DBR data types</a></li>
<li><a class="reference internal" href="#pysevchk-and-channelaccessexcepction-checking-ca-return-codes"><cite>PySEVCHK</cite> and ChannelAccessExcepction: checking CA return codes</a></li>
<li><a class="reference internal" href="#function-decorators">Function Decorators</a></li>
<li><a class="reference internal" href="#unpacking-data-from-callbacks">Unpacking Data from Callbacks</a></li>
</ul>
</li>
<li><a class="reference internal" href="#user-supplied-callback-functions">User-supplied Callback functions</a></li>
<li><a class="reference internal" href="#omissions">Omissions</a></li>
<li><a class="reference internal" href="#cathread-class"><tt class="docutils literal"><span class="pre">CAThread</span></tt> class</a></li>
<li><a class="reference internal" href="#examples">Examples</a><ul>
<li><a class="reference internal" href="#create-connect-get-value-of-channel">Create, Connect, Get Value of Channel</a></li>
<li><a class="reference internal" href="#put-waiting-for-completion">Put, waiting for completion</a></li>
<li><a class="reference internal" href="#define-a-callback-to-subscribe-to-changes">Define a callback to Subscribe to Changes</a></li>
<li><a class="reference internal" href="#define-a-connection-callback">Define a connection callback</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="pv.html"
                        title="previous chapter">The Epics PV class</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="advanced.html"
                        title="next chapter">Advanced Topic with Python Channel Access</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/ca.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" size="18" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="epics-ca-low-level-epics-interface">
<h1><tt class="xref py py-mod docutils literal"><span class="pre">epics.ca</span></tt> Low-Level Epics Interface<a class="headerlink" href="#epics-ca-low-level-epics-interface" title="Permalink to this headline">¶</a></h1>
<div class="section" id="general-description-difference-with-c-library">
<h2>General description, difference with C library<a class="headerlink" href="#general-description-difference-with-c-library" title="Permalink to this headline">¶</a></h2>
<p>This module provides a low-level wrapping of the EPICS Channel Access (CA)
library, using ctypes.  Most users of the <cite>epics</cite> module will not need to
be concerned with most of the details here, and will instead use the simple
functional interface (<a class="reference internal" href="overview.html#epics.caget" title="epics.caget"><tt class="xref py py-func docutils literal"><span class="pre">epics.caget()</span></tt></a>, <a class="reference internal" href="overview.html#epics.caput" title="epics.caput"><tt class="xref py py-func docutils literal"><span class="pre">epics.caput()</span></tt></a> and so on),
or use the <tt class="xref py py-class docutils literal"><span class="pre">epics.PV</span></tt> class to create and use epics PV objects.</p>
<p>The goal of this <a class="reference internal" href="#module-ca" title="ca: low-level Channel Access  module."><tt class="xref py py-mod docutils literal"><span class="pre">ca</span></tt></a> module is to stay fairly close to the C
interface to the CA library while also providing a pleasant Python
experience.  It is expected that anyone looking into the details of this
module is somewhat familiar with Channel Access and knows where to consult
the <a class="reference external" href="http://www.aps.anl.gov/epics/base/R3-14/11-docs/CAref.html">Channel Access Reference Documentation</a>.  This
document focuses on the differences with the C interface, assuming a
general understanding of what the functions are meant to do.</p>
<div class="section" id="name-mangling">
<h3>Name Mangling<a class="headerlink" href="#name-mangling" title="Permalink to this headline">¶</a></h3>
<p>As a general rule, a CA function named <cite>ca_XXX</cite> in the C library will have the
equivalent function called <cite>XXX</cite> in the <cite>ca</cite> module.  This is because the
intention is that one will import the <cite>ca</cite> module with</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">epics</span> <span class="kn">import</span> <span class="n">ca</span>
</pre></div>
</div>
<p>so that the Python function <tt class="xref py py-func docutils literal"><span class="pre">ca.XXX()</span></tt> will corresponds to the C
function <cite>ca_XXX</cite>.  That is, the CA library called its functions <cite>ca_XXX</cite>
because C does not have namespaces.  Python does have namespaces, and so
they are used.</p>
<p>Similar name <em>un-mangling</em> also happens with the DBR prefixes for
constants, held here in the <cite>dbr</cite> module.  Thus, the C constant DBR_STRING
becomes dbr.STRING in Python.</p>
</div>
<div class="section" id="other-changes-and-omissions">
<h3>Other Changes and Omissions<a class="headerlink" href="#other-changes-and-omissions" title="Permalink to this headline">¶</a></h3>
<p>Several function in the C version of the CA library are not implemented in
the Python module.  Most of these unimplemented functions are currently
seen as unnecessary for Python, though some of these could be added without
much trouble if needed. See <a class="reference internal" href="#ca-omissions-label"><em>Omissions</em></a> for further details.</p>
<p>In addition, while the CA library supports several <cite>DBR</cite> types in C, not
all of these are supported in Python. Only native types and their DBR_TIME
and DBR_CTRL variants are supported here.  The DBR_STS and DBR_GR variants
are not, as they are subsets of the DBR_CTRL type, and space optimization
is not something you'll be striving for with Python.  Several <cite>dbr_XXX</cite>
functions are also not supported, as they appear to be needed only to be
able to dynamically allocate memory, which is not necessary in Python.</p>
</div>
</div>
<div class="section" id="module-ca">
<span id="initialization-finalization-and-life-cycle"></span><span id="ca-init-label"></span><h2>Initialization, Finalization, and Life-cycle<a class="headerlink" href="#module-ca" title="Permalink to this headline">¶</a></h2>
<p>The Channel Access library must be initialized before it can be used.
There are 3 main reasons for this need:</p>
<blockquote>
<div><p>1. CA requires a context model (preemptive callbacks or  non-preemptive
callbacks) to be specified before any actual calls can be made.</p>
<p>2. the ctypes interface requires that the shared library be loaded
before it is used.</p>
<p>3. ctypes also requires that references to the library and callback
functions be kept for the life-cycle of CA-using part of a program (or
else they will be garbage collected).</p>
</div></blockquote>
<p>As far as is possible, the <a class="reference internal" href="#module-ca" title="ca: low-level Channel Access  module."><tt class="xref py py-mod docutils literal"><span class="pre">ca</span></tt></a> module hides the details of the CA
lifecyle from the user, so that it is not necessary to to worry about
explicitly initializing a Channel Access session.  Instead, the library is
initialized as soon as it is needed, and intervention is really only
required to change default settings.  The <a class="reference internal" href="#module-ca" title="ca: low-level Channel Access  module."><tt class="xref py py-mod docutils literal"><span class="pre">ca</span></tt></a> module also handles
finalizing the CA session, so that core-dumps and warning messages do not
happen due to CA still being 'alive' as a program ends.</p>
<p>Because some users may wish to customize the initialization and
finalization process, the detailed steps will be described here.  These
initialization and finalization tasks are handled in the following way:</p>
<blockquote>
<div><ul class="simple">
<li>The <tt class="xref py py-data docutils literal"><span class="pre">libca</span></tt> variable in the <a class="reference internal" href="#module-ca" title="ca: low-level Channel Access  module."><tt class="xref py py-mod docutils literal"><span class="pre">ca</span></tt></a> module holds a permanent,
global reference to the CA shared object library (DLL).</li>
<li>the function <a class="reference internal" href="#ca.initialize_libca" title="ca.initialize_libca"><tt class="xref py py-func docutils literal"><span class="pre">initialize_libca()</span></tt></a> is called to initialize libca.
This function takes no arguments, but does use the global Boolean
<a class="reference internal" href="#ca.PREEMPTIVE_CALLBACK" title="ca.PREEMPTIVE_CALLBACK"><tt class="xref py py-data docutils literal"><span class="pre">PREEMPTIVE_CALLBACK</span></tt></a> (default value of <tt class="xref docutils literal"><span class="pre">True</span></tt>) to control
whether preemptive callbacks are used.</li>
<li>the function <tt class="xref py py-func docutils literal"><span class="pre">finalize_libca()</span></tt> is used to finalize libca.
Normally, this is function is registered to be called when a program
ends with <tt class="xref py py-func docutils literal"><span class="pre">atexit.register()</span></tt>.  Note that this only gets called on
a graceful shutdown. If the program crashes (for a non-CA related
reason, for example), this finalization may not be done, and
connections to Epics Variables may not be closed completely on the
Channel Access server.</li>
</ul>
</div></blockquote>
<dl class="data">
<dt id="ca.PREEMPTIVE_CALLBACK">
<tt class="descclassname">ca.</tt><tt class="descname">PREEMPTIVE_CALLBACK</tt><a class="headerlink" href="#ca.PREEMPTIVE_CALLBACK" title="Permalink to this definition">¶</a></dt>
<dd><p>sets whether preemptive callbacks will be used.  The default value is
<tt class="xref docutils literal"><span class="pre">True</span></tt>.  If you wish to run without preemptive callbacks this variable
<em>MUST</em> be set before any other use of the CA library.  With preemptive
callbacks enabled, EPICS communication will not require client code to
continually poll for changes.   With preemptive callback disables,  you
will need to frequently poll epics with <a class="reference internal" href="#ca.pend_io" title="ca.pend_io"><tt class="xref py py-func docutils literal"><span class="pre">pend_io()</span></tt></a> and
func:<cite>pend_event</cite>.</p>
</dd></dl>

<dl class="data">
<dt id="ca.DEFAULT_CONNECTION_TIMEOUT">
<tt class="descclassname">ca.</tt><tt class="descname">DEFAULT_CONNECTION_TIMEOUT</tt><a class="headerlink" href="#ca.DEFAULT_CONNECTION_TIMEOUT" title="Permalink to this definition">¶</a></dt>
<dd><p>sets the default <cite>timeout</cite> value (in seconds) for
<a class="reference internal" href="#ca.connect_channel" title="ca.connect_channel"><tt class="xref py py-func docutils literal"><span class="pre">connect_channel()</span></tt></a>.  The default value is <cite>2.0</cite></p>
</dd></dl>

<dl class="data">
<dt id="ca.AUTOMONITOR_MAXLENGTH">
<tt class="descclassname">ca.</tt><tt class="descname">AUTOMONITOR_MAXLENGTH</tt><a class="headerlink" href="#ca.AUTOMONITOR_MAXLENGTH" title="Permalink to this definition">¶</a></dt>
<dd><p>sets the default array length (ie, how many elements an array has) above
which automatic conversion to numpy arrays <em>and</em> automatic monitoring
for PV variables is suppressed.  The default value is 16384.  To be
clear: waveforms with fewer elements than this value will be
automatically monitored changes, and will be converted to numpy arrays
(if numpy is installed).  Larger waveforms will not be monitored.</p>
<p><a class="reference internal" href="advanced.html#advanced-large-arrays-label"><em>Strategies for working with large arrays</em></a> for more details.</p>
</dd></dl>

</div>
<div class="section" id="using-the-ca-module">
<h2>Using the CA module<a class="headerlink" href="#using-the-ca-module" title="Permalink to this headline">¶</a></h2>
<p>Many general-purpose CA functions that deal with general communication and
threading contexts are very close to the C library:</p>
<dl class="function">
<dt id="ca.initialize_libca">
<tt class="descclassname">ca.</tt><tt class="descname">initialize_libca</tt><big>(</big><big>)</big><a class="headerlink" href="#ca.initialize_libca" title="Permalink to this definition">¶</a></dt>
<dd><p>This initializes the CA library.  This must be called prior to any
actual use of the CA library, but it is called automatically by the  <a class="reference internal" href="#ca.withCA" title="ca.withCA"><tt class="xref py py-func docutils literal"><span class="pre">withCA()</span></tt></a>
decorator, so you should never need to call this in a real program.</p>
</dd></dl>

<dl class="function">
<dt id="ca.context_create">
<tt class="descclassname">ca.</tt><tt class="descname">context_create</tt><big>(</big><big>)</big><a class="headerlink" href="#ca.context_create" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="ca.create_context">
<tt class="descclassname">ca.</tt><tt class="descname">create_context</tt><big>(</big><big>)</big><a class="headerlink" href="#ca.create_context" title="Permalink to this definition">¶</a></dt>
<dd><p>This will create a new context, using the value of <a class="reference internal" href="#ca.PREEMPTIVE_CALLBACK" title="ca.PREEMPTIVE_CALLBACK"><tt class="xref py py-data docutils literal"><span class="pre">PREEMPTIVE_CALLBACK</span></tt></a> to set
the context type. Note that CA library function has the irritating name of
<em>context_create</em>.  Both that and <em>create_context</em> (which is more consistent with the
Verb_Object of the rest of the CA library) are allowed.</p>
</dd></dl>

<dl class="function">
<dt id="ca.context_destroy">
<tt class="descclassname">ca.</tt><tt class="descname">context_destroy</tt><big>(</big><big>)</big><a class="headerlink" href="#ca.context_destroy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="ca.destroy_context">
<tt class="descclassname">ca.</tt><tt class="descname">destroy_context</tt><big>(</big><big>)</big><a class="headerlink" href="#ca.destroy_context" title="Permalink to this definition">¶</a></dt>
<dd><p>This will destroy the current context.</p>
</dd></dl>

<dl class="function">
<dt id="ca.current_context">
<tt class="descclassname">ca.</tt><tt class="descname">current_context</tt><big>(</big><big>)</big><a class="headerlink" href="#ca.current_context" title="Permalink to this definition">¶</a></dt>
<dd><p>This returns an integer value for the current context.</p>
</dd></dl>

<dl class="function">
<dt id="ca.attach_context">
<tt class="descclassname">ca.</tt><tt class="descname">attach_context</tt><big>(</big><em>context</em><big>)</big><a class="headerlink" href="#ca.attach_context" title="Permalink to this definition">¶</a></dt>
<dd><p>This attaches to the context supplied.</p>
</dd></dl>

<dl class="function">
<dt id="ca.detach_context">
<tt class="descclassname">ca.</tt><tt class="descname">detach_context</tt><big>(</big><big>)</big><a class="headerlink" href="#ca.detach_context" title="Permalink to this definition">¶</a></dt>
<dd><p>This detaches from the current context.</p>
</dd></dl>

<dl class="function">
<dt id="ca.use_initial_context">
<tt class="descclassname">ca.</tt><tt class="descname">use_initial_context</tt><big>(</big><big>)</big><a class="headerlink" href="#ca.use_initial_context" title="Permalink to this definition">¶</a></dt>
<dd><p>This attaches to the context created when libca is initialized.
Using this function is recommended when writing Threaded programs that
using CA.  See <a class="reference internal" href="advanced.html#advanced-threads-label"><em>Using Python Threads</em></a> for further discussion.</p>
</dd></dl>

<dl class="function">
<dt id="ca.client_status">
<tt class="descclassname">ca.</tt><tt class="descname">client_status</tt><big>(</big><em>context</em>, <em>level</em><big>)</big><a class="headerlink" href="#ca.client_status" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="ca.message">
<tt class="descclassname">ca.</tt><tt class="descname">message</tt><big>(</big><em>status</em><big>)</big><a class="headerlink" href="#ca.message" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="ca.flush_io">
<tt class="descclassname">ca.</tt><tt class="descname">flush_io</tt><big>(</big><big>)</big><a class="headerlink" href="#ca.flush_io" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="ca.replace_printf_handler">
<tt class="descclassname">ca.</tt><tt class="descname">replace_printf_handler</tt><big>(</big><em>fcn</em><big>)</big><a class="headerlink" href="#ca.replace_printf_handler" title="Permalink to this definition">¶</a></dt>
<dd><p>replace the <tt class="xref py py-func docutils literal"><span class="pre">printf()</span></tt> function with the supplied function (defaults
to <tt class="xref py py-func docutils literal"><span class="pre">sys.stderr.write()</span></tt> )</p>
</dd></dl>

<dl class="function">
<dt id="ca.pend_io">
<tt class="descclassname">ca.</tt><tt class="descname">pend_io</tt><big>(</big><span class="optional">[</span><em>t=1.0</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#ca.pend_io" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="ca.pend_event">
<tt class="descclassname">ca.</tt><tt class="descname">pend_event</tt><big>(</big><span class="optional">[</span><em>t=1.e-5</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#ca.pend_event" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="ca.poll">
<tt class="descclassname">ca.</tt><tt class="descname">poll</tt><big>(</big><span class="optional">[</span><em>evt=1.e-5</em><span class="optional">[</span>, <em>iot=1.0</em><span class="optional">]</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#ca.poll" title="Permalink to this definition">¶</a></dt>
<dd><p>a convenience function which is equivalent to:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">pend_event</span><span class="p">(</span><span class="n">evt</span><span class="p">)</span>
<span class="n">pend_io_</span><span class="p">(</span><span class="n">iot</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<div class="section" id="creating-and-connecting-to-channels">
<h3>Creating and Connecting to Channels<a class="headerlink" href="#creating-and-connecting-to-channels" title="Permalink to this headline">¶</a></h3>
<p>The basic channel object is the Channel ID or <tt class="docutils literal"><span class="pre">chid</span></tt>.  With the CA
library (and <tt class="docutils literal"><span class="pre">ca</span></tt> module), one creates and acts on the <tt class="docutils literal"><span class="pre">chid</span></tt> values.
These are simply <tt class="xref py py-data docutils literal"><span class="pre">ctypes.c_long</span></tt> (C long integers) that hold the
memory address of the C representation of the channel, but it is probably
a good idea to treat these as object instances.</p>
<dl class="function">
<dt id="ca.create_channel">
<tt class="descclassname">ca.</tt><tt class="descname">create_channel</tt><big>(</big><em>pvname, [connect=False, [callback=None, auto_cb=True]]]</em><big>)</big><a class="headerlink" href="#ca.create_channel" title="Permalink to this definition">¶</a></dt>
<dd><p>creates a channel, returning the Channel ID <tt class="docutils literal"><span class="pre">chid</span></tt> used by other
functions to identify this channel.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>pvname</strong> -- the name of the PV to create.</li>
<li><strong>connect</strong> (<tt class="xref docutils literal"><span class="pre">True</span></tt>/<tt class="xref docutils literal"><span class="pre">False</span></tt>) -- whether to (try to) connect to PV as soon as possible.</li>
<li><strong>callback</strong> (<tt class="xref docutils literal"><span class="pre">None</span></tt> or callable.) -- user-defined Python function to be called when the connection state changes.</li>
<li><strong>auto_cb</strong> (<tt class="xref docutils literal"><span class="pre">True</span></tt>/<tt class="xref docutils literal"><span class="pre">False</span></tt>) -- whether to automatically use an internal callback.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>The user-defined callback function should be  prepared to accept keyword arguments of</dt>
<dd><ul class="first last simple">
<li><cite>pvname</cite>  name of PV</li>
<li><cite>chid</cite>    <tt class="docutils literal"><span class="pre">chid</span></tt> Channel ID</li>
<li><cite>conn</cite>    <tt class="xref docutils literal"><span class="pre">True</span></tt>/<tt class="xref docutils literal"><span class="pre">False</span></tt>:  whether channel is connected.</li>
</ul>
</dd>
</dl>
<p>If <cite>auto_cb</cite> is <tt class="xref docutils literal"><span class="pre">True</span></tt>, an internal connection callback is used so
that you should not need to explicitly connect to a channel, unless you
are having difficulty with dropped connections.</p>
</dd></dl>

<dl class="function">
<dt id="ca.connect_channel">
<tt class="descclassname">ca.</tt><tt class="descname">connect_channel</tt><big>(</big><em>chid</em><span class="optional">[</span>, <em>timeout=None</em><span class="optional">[</span>, <em>verbose=False</em><span class="optional">]</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#ca.connect_channel" title="Permalink to this definition">¶</a></dt>
<dd><p>explicitly connect to a channel (usually not needed, as implicit
connection will be done when needed), waiting up to timeout for a
channel to connect.  It returns the connection state, <tt class="xref docutils literal"><span class="pre">True</span></tt> or
<tt class="xref docutils literal"><span class="pre">False</span></tt>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>chid</strong> -- <tt class="docutils literal"><span class="pre">chid</span></tt> Channel ID</li>
<li><strong>timeout</strong> (float or <tt class="xref docutils literal"><span class="pre">None</span></tt>.) -- maximum time to wait for connection.</li>
<li><strong>verbose</strong> -- whether to print out debugging information</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>if <em>timeout</em> is <tt class="xref docutils literal"><span class="pre">None</span></tt>, the value of  <a class="reference internal" href="#ca.DEFAULT_CONNECTION_TIMEOUT" title="ca.DEFAULT_CONNECTION_TIMEOUT"><tt class="xref py py-data docutils literal"><span class="pre">DEFAULT_CONNECTION_TIMEOUT</span></tt></a>
is used (usually 2.0 seconds).</p>
<p>Normally, channels will connect in milliseconds, and the connection
callback will succeed on the first attempt.</p>
<p>For un-connected Channels (that are nevertheless queried), the 'ts'
(timestamp of last connection attempt) and 'failures' (number of failed
connection attempts) from the <a class="reference internal" href="#ca._cache" title="ca._cache"><tt class="xref py py-data docutils literal"><span class="pre">_cache</span></tt></a> will be used to prevent
spending too much time waiting for a connection that may never happen.</p>
</dd></dl>

<p>Many other functions that require a valid Channel ID, but not necessarily a
connected Channel.  These functions are essentially identical to the CA
library are:</p>
<dl class="function">
<dt id="ca.name">
<tt class="descclassname">ca.</tt><tt class="descname">name</tt><big>(</big><em>chid</em><big>)</big><a class="headerlink" href="#ca.name" title="Permalink to this definition">¶</a></dt>
<dd><p>return PV name for Channel.</p>
</dd></dl>

<dl class="function">
<dt id="ca.host_name">
<tt class="descclassname">ca.</tt><tt class="descname">host_name</tt><big>(</big><em>chid</em><big>)</big><a class="headerlink" href="#ca.host_name" title="Permalink to this definition">¶</a></dt>
<dd><p>return host name and port serving Channel.</p>
</dd></dl>

<dl class="function">
<dt id="ca.element_count">
<tt class="descclassname">ca.</tt><tt class="descname">element_count</tt><big>(</big><em>chid</em><big>)</big><a class="headerlink" href="#ca.element_count" title="Permalink to this definition">¶</a></dt>
<dd><p>return number of elements in Channel's data.</p>
</dd></dl>

<dl class="function">
<dt id="ca.read_access">
<tt class="descclassname">ca.</tt><tt class="descname">read_access</tt><big>(</big><em>chid</em><big>)</big><a class="headerlink" href="#ca.read_access" title="Permalink to this definition">¶</a></dt>
<dd><p>return <em>read access</em> for a Channel: 1 for <tt class="xref docutils literal"><span class="pre">True</span></tt>, 0 for <tt class="xref docutils literal"><span class="pre">False</span></tt>.</p>
</dd></dl>

<dl class="function">
<dt id="ca.write_access">
<tt class="descclassname">ca.</tt><tt class="descname">write_access</tt><big>(</big><em>chid</em><big>)</big><a class="headerlink" href="#ca.write_access" title="Permalink to this definition">¶</a></dt>
<dd><p>return <em>write access</em> for a channel: 1 for <tt class="xref docutils literal"><span class="pre">True</span></tt>, 0 for <tt class="xref docutils literal"><span class="pre">False</span></tt>.</p>
</dd></dl>

<dl class="function">
<dt id="ca.field_type">
<tt class="descclassname">ca.</tt><tt class="descname">field_type</tt><big>(</big><em>chid</em><big>)</big><a class="headerlink" href="#ca.field_type" title="Permalink to this definition">¶</a></dt>
<dd><p>return the integer DBR field type. See the <em>ftype</em> column from
<a class="reference internal" href="#dbrtype-table"><em>Table of DBR Types</em></a>.</p>
</dd></dl>

<dl class="function">
<dt id="ca.clear_channel">
<tt class="descclassname">ca.</tt><tt class="descname">clear_channel</tt><big>(</big><em>chid</em><big>)</big><a class="headerlink" href="#ca.clear_channel" title="Permalink to this definition">¶</a></dt>
<dd><p>clear the channel.</p>
</dd></dl>

<dl class="function">
<dt id="ca.state">
<tt class="descclassname">ca.</tt><tt class="descname">state</tt><big>(</big><em>chid</em><big>)</big><a class="headerlink" href="#ca.state" title="Permalink to this definition">¶</a></dt>
<dd><p>return the state of the channel.</p>
</dd></dl>

<p>A few additional pythonic functions have been added:</p>
<dl class="function">
<dt id="ca.isConnected">
<tt class="descclassname">ca.</tt><tt class="descname">isConnected</tt><big>(</big><em>chid</em><big>)</big><a class="headerlink" href="#ca.isConnected" title="Permalink to this definition">¶</a></dt>
<dd><p>returns <cite>dbr.CS_CONN==state(chid)</cite> ie <tt class="xref docutils literal"><span class="pre">True</span></tt> for a connected channel
or <tt class="xref docutils literal"><span class="pre">False</span></tt> for an unconnected channel.</p>
</dd></dl>

<dl class="function">
<dt id="ca.access">
<tt class="descclassname">ca.</tt><tt class="descname">access</tt><big>(</big><em>chid</em><big>)</big><a class="headerlink" href="#ca.access" title="Permalink to this definition">¶</a></dt>
<dd><p>returns a string describing read/write access: one of
<cite>no access</cite>, <cite>read-only</cite>, <cite>write-only</cite>, or <cite>read/write</cite></p>
</dd></dl>

<dl class="function">
<dt id="ca.promote_type">
<tt class="descclassname">ca.</tt><tt class="descname">promote_type</tt><big>(</big><em>chid</em><span class="optional">[</span>, <em>use_time=False</em><span class="optional">[</span>, <em>use_ctrl=False</em><span class="optional">]</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#ca.promote_type" title="Permalink to this definition">¶</a></dt>
<dd><p>promotes the native field type of a <tt class="docutils literal"><span class="pre">chid</span></tt> to its TIME or CTRL
variant. See <a class="reference internal" href="#dbrtype-table"><em>Table of DBR Types</em></a>.  Returns the
integer corresponding to the promoted field value.</p>
</dd></dl>

<dl class="data">
<dt id="ca._cache">
<tt class="descclassname">ca.</tt><tt class="descname">_cache</tt><a class="headerlink" href="#ca._cache" title="Permalink to this definition">¶</a></dt>
<dd><p>The ca module keeps a global cache of Channels that holds connection
status and a bit of internal information for all known PVs.  This cache
is not intended for general use.</p>
</dd></dl>

<dl class="function">
<dt id="ca.show_cache">
<tt class="descclassname">ca.</tt><tt class="descname">show_cache</tt><big>(</big><span class="optional">[</span><em>print_out=True</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#ca.show_cache" title="Permalink to this definition">¶</a></dt>
<dd><p>this function will print out a listing of PVs in the current session to
standard output.  Use the <em>print_out=False</em> option to be returned the
listing instead of having it printed.</p>
</dd></dl>

</div>
<div class="section" id="interacting-with-connected-channels">
<h3>Interacting with Connected Channels<a class="headerlink" href="#interacting-with-connected-channels" title="Permalink to this headline">¶</a></h3>
<p>Once a <tt class="docutils literal"><span class="pre">chid</span></tt> is created and connected there are several ways to
communicating with it.  These are primarily encapsulated in the functions
<a class="reference internal" href="#ca.get" title="ca.get"><tt class="xref py py-func docutils literal"><span class="pre">get()</span></tt></a>, <a class="reference internal" href="#ca.put" title="ca.put"><tt class="xref py py-func docutils literal"><span class="pre">put()</span></tt></a>, and <a class="reference internal" href="#ca.create_subscription" title="ca.create_subscription"><tt class="xref py py-func docutils literal"><span class="pre">create_subscription()</span></tt></a>, with a few
additional functions for retrieving specific information.</p>
<p>These functions are where this python module differs the most from the
underlying CA library, and this is mostly due to the underlying CA function
requiring the user to supply DBR TYPE and count as well as <tt class="docutils literal"><span class="pre">chid</span></tt> and
allocated space for the data.  In python none of these is needed, and
keyword arguments can be used to specify such options.</p>
<dl class="method">
<dt id="ca.get">
<tt class="descclassname">ca.</tt><tt class="descname">get</tt><big>(</big><em>chid</em><span class="optional">[</span>, <em>ftype=None</em><span class="optional">[</span>, <em>count=None</em><span class="optional">[</span>, <em>as_string=False</em><span class="optional">[</span>, <em>as_numpy=True</em><span class="optional">[</span>, <em>wait=True</em><span class="optional">[</span>, <em>timeout=None</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#ca.get" title="Permalink to this definition">¶</a></dt>
<dd><p>return the current value for a Channel. Note that there is not a separate form for array data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>chid</strong> (<em>ctypes.c_long</em>) -- <tt class="docutils literal"><span class="pre">chid</span></tt> Channel ID</li>
<li><strong>ftype</strong> (integer or <tt class="xref docutils literal"><span class="pre">None</span></tt>) -- field type to use (native type is default)</li>
<li><strong>count</strong> (integer or <tt class="xref docutils literal"><span class="pre">None</span></tt>) -- maximum element count to return (full data returned by default)</li>
<li><strong>as_string</strong> (<tt class="xref docutils literal"><span class="pre">True</span></tt>/<tt class="xref docutils literal"><span class="pre">False</span></tt>) -- whether to return the string representation of the value.  See notes below.</li>
<li><strong>as_numpy</strong> (<tt class="xref docutils literal"><span class="pre">True</span></tt>/<tt class="xref docutils literal"><span class="pre">False</span></tt>) -- whether to return the Numerical Python representation  for array / waveform data.</li>
<li><strong>wait</strong> (<tt class="xref docutils literal"><span class="pre">True</span></tt>/<tt class="xref docutils literal"><span class="pre">False</span></tt>) -- whether to wait for the data to be received, or return immediately.</li>
<li><strong>timeout</strong> (float or <tt class="xref docutils literal"><span class="pre">None</span></tt>) -- maximum time to wait for data before returning <tt class="xref docutils literal"><span class="pre">None</span></tt>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p><a class="reference internal" href="#ca.get" title="ca.get"><tt class="xref py py-func docutils literal"><span class="pre">get()</span></tt></a> returns the value for the PV with channel ID <em>chid</em> or
<tt class="xref docutils literal"><span class="pre">None</span></tt>, which indicates an <em>incomplete get</em></p>
<p>For a listing of values of <em>ftype</em>, see <a class="reference internal" href="#dbrtype-table"><em>Table of DBR Types</em></a>.  The optional <em>count</em> can be used to limit the
amount of data returned for array data from waveform records.</p>
<p>The <em>as_string</em> option warrants special attention: The feature is not
as complete as as the <em>as_string</em> argument for <tt class="xref py py-meth docutils literal"><span class="pre">PV.get()</span></tt>.  Here,
a string representing the value will always be returned. For Enum
types, the name of the Enum state will be returned.  For waveforms of
type CHAR, the string representation will be returned.  For other
waveforms (with <em>count</em> &gt; 1), a string like <cite>&lt;array count=3, type=1&gt;</cite>
will be returned.  For all other types the result will from Python's
<tt class="xref py py-func docutils literal"><span class="pre">str()</span></tt> function.</p>
<p>The <em>as_numpy</em> option will cause an array value to be returned as a
numpy array.  This is only applied if numpy can be imported.  See
<a class="reference internal" href="advanced.html#advanced-large-arrays-label"><em>Strategies for working with large arrays</em></a> for a discussion of strategies for
how to best deal with very large arrays.</p>
<p>The <em>wait</em> option controls whether to wait for the data to be
received over the network and actually return the value, or to return
immediately after asking for it to be sent.  If <cite>wait=False</cite> (that
is, immediate return), the <em>get</em> operation is said to be
<em>incomplete</em>.  The data will be still be received (unless the channel
is disconnected) eventually but stored internally, and can be read
later with <a class="reference internal" href="#ca.get_complete" title="ca.get_complete"><tt class="xref py py-func docutils literal"><span class="pre">get_complete()</span></tt></a>.  Using <cite>wait=False</cite> can be useful in
some circumstances.  See <a class="reference internal" href="advanced.html#advanced-connecting-many-label"><em>Strategies for connecting to a large number of PVs</em></a> for a
discussion.</p>
<p>The <em>timeout</em> option sets the maximum time to wait for the data to be
received over the network before returning <tt class="xref docutils literal"><span class="pre">None</span></tt>.  Such a timeout
could imply that the channel is disconnected or that the data size is
larger or network slower than normal.  In that case, the <em>get</em>
operation is said to be <em>incomplete</em>, and the data may become
available later with <a class="reference internal" href="#ca.get_complete" title="ca.get_complete"><tt class="xref py py-func docutils literal"><span class="pre">get_complete()</span></tt></a>.</p>
<p>See <a class="reference internal" href="advanced.html#advanced-get-timeouts-label"><em>The wait and timeout options for get(), ca.get_complete()</em></a> for further discussion of the
<em>wait</em> and <em>timeout</em> options and the associated <a class="reference internal" href="#ca.get_complete" title="ca.get_complete"><tt class="xref py py-func docutils literal"><span class="pre">get_complete()</span></tt></a>
function.</p>
</dd></dl>

<dl class="method">
<dt id="ca.get_complete">
<tt class="descclassname">ca.</tt><tt class="descname">get_complete</tt><big>(</big><em>chid</em><span class="optional">[</span>, <em>ftype=None</em><span class="optional">[</span>, <em>count=None</em><span class="optional">[</span>, <em>as_string=False</em><span class="optional">[</span>, <em>as_numpy=True</em><span class="optional">[</span>, <em>timeout=None</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#ca.get_complete" title="Permalink to this definition">¶</a></dt>
<dd><p>return the current value for a Channel, completing an earlier incomplete
<a class="reference internal" href="#ca.get" title="ca.get"><tt class="xref py py-func docutils literal"><span class="pre">get()</span></tt></a> that returned <tt class="xref docutils literal"><span class="pre">None</span></tt>, either because <cite>wait=False</cite> was
used or because the data transfer did not complete before the timeout passed.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>chid</strong> (<em>ctypes.c_long</em>) -- <tt class="docutils literal"><span class="pre">chid</span></tt> Channel ID</li>
<li><strong>ftype</strong> (<em>integer</em>) -- field type to use (native type is default)</li>
<li><strong>count</strong> (<em>integer</em>) -- maximum element count to return (full data returned by default)</li>
<li><strong>as_string</strong> (<tt class="xref docutils literal"><span class="pre">True</span></tt>/<tt class="xref docutils literal"><span class="pre">False</span></tt>) -- whether to return the string representation of the value.  See notes below.</li>
<li><strong>as_numpy</strong> (<tt class="xref docutils literal"><span class="pre">True</span></tt>/<tt class="xref docutils literal"><span class="pre">False</span></tt>) -- whether to return the Numerical Python representation  for array / waveform data.</li>
<li><strong>timeout</strong> (float or <tt class="xref docutils literal"><span class="pre">None</span></tt>) -- maximum time to wait for data before returning <tt class="xref docutils literal"><span class="pre">None</span></tt>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>This function will return <tt class="xref docutils literal"><span class="pre">None</span></tt> if the previous <a class="reference internal" href="#ca.get" title="ca.get"><tt class="xref py py-func docutils literal"><span class="pre">get()</span></tt></a>
actually completed, or if this data transfer also times out.  See
<a class="reference internal" href="advanced.html#advanced-get-timeouts-label"><em>The wait and timeout options for get(), ca.get_complete()</em></a> for further discussion.</p>
</dd></dl>

<dl class="method">
<dt id="ca.put">
<tt class="descclassname">ca.</tt><tt class="descname">put</tt><big>(</big><em>chid</em>, <em>value</em><span class="optional">[</span>, <em>wait=False</em><span class="optional">[</span>, <em>timeout=30</em><span class="optional">[</span>, <em>callback=None</em><span class="optional">[</span>, <em>callback_data=None</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#ca.put" title="Permalink to this definition">¶</a></dt>
<dd><p>sets the Channel to a value, with options to either wait (block) for the
process to complete, or to execute a supplied callback function when the
process has completed.  The chid and value are required.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>chid</strong> (<em>ctypes.c_long</em>) -- <tt class="docutils literal"><span class="pre">chid</span></tt> Channel ID</li>
<li><strong>wait</strong> (<tt class="xref docutils literal"><span class="pre">True</span></tt>/<tt class="xref docutils literal"><span class="pre">False</span></tt>) -- whether to wait for processing to complete (or time-out) before returning.</li>
<li><strong>timeout</strong> (float or <tt class="xref docutils literal"><span class="pre">None</span></tt>) -- maximum time to wait for processing to complete before returning anyway.</li>
<li><strong>callback</strong> (<tt class="xref docutils literal"><span class="pre">None</span></tt> or callable) -- user-supplied function to run when processing has completed.</li>
<li><strong>callback_data</strong> -- extra data to pass on to a user-supplied callback function.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p><a class="reference internal" href="#ca.put" title="ca.put"><tt class="xref py py-meth docutils literal"><span class="pre">put()</span></tt></a> returns 1 on success and -1 on timed-out</p>
<p>Specifying a callback will override setting <cite>wait=True</cite>.  This
callback function will be called with keyword arguments</p>
<blockquote>
<div>pvname=pvname, data=callback_data</div></blockquote>
<p>For more on this <em>put callback</em>, see <a class="reference internal" href="#ca-callbacks-label"><em>User-supplied Callback functions</em></a> below.</p>
</dd></dl>

<dl class="method">
<dt id="ca.create_subscription">
<tt class="descclassname">ca.</tt><tt class="descname">create_subscription</tt><big>(</big><em>chid</em><span class="optional">[</span>, <em>use_time=False</em><span class="optional">[</span>, <em>use_ctrl=False</em><span class="optional">[</span>, <em>mask=None</em><span class="optional">[</span>, <em>callback=None</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#ca.create_subscription" title="Permalink to this definition">¶</a></dt>
<dd><p>create a <em>subscription to changes</em>, The user-supplied callback function
will be called on any changes to the PV.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>use_time</strong> (<tt class="xref docutils literal"><span class="pre">True</span></tt>/<tt class="xref docutils literal"><span class="pre">False</span></tt>) -- whether to use the TIME variant for the PV type</li>
<li><strong>use_ctrl</strong> (<tt class="xref docutils literal"><span class="pre">True</span></tt>/<tt class="xref docutils literal"><span class="pre">False</span></tt>) -- whether to use the CTRL variant for the PV type</li>
<li><strong>mask</strong> (<em>integer</em>) -- bitmask (combination of dbr.DBE_ALARM, dbr.DBE_LOG, dbr.DBE_VALUE) to control which changes result in a callback. Defaults to <a class="reference internal" href="#ca.DEFAULT_SUBSCRIPTION_MASK" title="ca.DEFAULT_SUBSCRIPTION_MASK"><tt class="xref py py-data docutils literal"><span class="pre">DEFAULT_SUBSCRIPTION_MASK</span></tt></a>.</li>
<li><strong>callback</strong> (<tt class="xref docutils literal"><span class="pre">None</span></tt> or callable) -- user-supplied callback function</li>
</ul>
</td>
</tr>
<tr class="field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">tuple containing <em>(callback_ref, user_arg_ref, event_id)</em></p>
</td>
</tr>
</tbody>
</table>
<p>The returned tuple contains <em>callback_ref</em> an <em>user_arg_ref</em> which are
references that should be kept for as long as the subscription lives
(otherwise they may be garbage collected, causing no end of trouble).
<em>event_id</em> is the id for the event (useful for clearing a subscription).</p>
<p>For more on writing the user-supplied callback, see <a class="reference internal" href="#ca-callbacks-label"><em>User-supplied Callback functions</em></a> below.</p>
</dd></dl>

<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p><em>event_id</em> is the id for the event (useful for clearing a subscription).
You <strong>must</strong> keep the returned tuple in active variables, either as a
global variable or as data in an encompassing class.
If you do <em>not</em> keep this data, the return value will be garbage
collected, the C-level reference to the callback will disappear, and you
will see coredumps.</p>
<p>On Linux, a message like:</p>
<div class="highlight-python"><pre>python: Objects/funcobject.c:451: func_dealloc: Assertion 'g-&gt;gc.gc_refs != (-2)' failed.
Abort (core dumped)</pre>
</div>
<p class="last">is a hint that you have <em>not</em> kept this data.</p>
</div>
<dl class="data">
<dt id="ca.DEFAULT_SUBSCRIPTION_MASK">
<tt class="descclassname">ca.</tt><tt class="descname">DEFAULT_SUBSCRIPTION_MASK</tt><a class="headerlink" href="#ca.DEFAULT_SUBSCRIPTION_MASK" title="Permalink to this definition">¶</a></dt>
<dd><p>This value is the default subscription type used when calling
<a class="reference internal" href="#ca.create_subscription" title="ca.create_subscription"><tt class="xref py py-meth docutils literal"><span class="pre">create_subscription()</span></tt></a> with <cite>mask=None</cite>. It is also used by
default when creating a <tt class="xref py py-class docutils literal"><span class="pre">PV</span></tt> object with auto_monitor is set
to <tt class="xref docutils literal"><span class="pre">True</span></tt>.</p>
<p>The initial default value is <em>dbr.DBE_ALARM|dbr.DBE_VALUE</em>
(i.e. update on alarm changes or value changes which exceeds the
monitor deadband.)  The other possible flag in the bitmask is
<em>dbr.DBE_LOG</em> for archive-deadband changes.</p>
<p>If this value is changed, it will change the default for all
subsequent calls to <a class="reference internal" href="#ca.create_subscription" title="ca.create_subscription"><tt class="xref py py-meth docutils literal"><span class="pre">create_subscription()</span></tt></a>, but it will not
change any existing subscriptions.</p>
</dd></dl>

<dl class="method">
<dt id="ca.clear_subscription">
<tt class="descclassname">ca.</tt><tt class="descname">clear_subscription</tt><big>(</big><em>event_id</em><big>)</big><a class="headerlink" href="#ca.clear_subscription" title="Permalink to this definition">¶</a></dt>
<dd><p>clears a subscription given its <em>event_id</em>.</p>
</dd></dl>

<p>Several other functions are provided:</p>
<dl class="method">
<dt id="ca.get_timestamp">
<tt class="descclassname">ca.</tt><tt class="descname">get_timestamp</tt><big>(</big><em>chid</em><big>)</big><a class="headerlink" href="#ca.get_timestamp" title="Permalink to this definition">¶</a></dt>
<dd><p>return the timestamp of a channel -- the time of last update.</p>
</dd></dl>

<dl class="function">
<dt id="ca.get_severity">
<tt class="descclassname">ca.</tt><tt class="descname">get_severity</tt><big>(</big><em>chid</em><big>)</big><a class="headerlink" href="#ca.get_severity" title="Permalink to this definition">¶</a></dt>
<dd><p>return the severity of a channel.</p>
</dd></dl>

<dl class="function">
<dt id="ca.get_precision">
<tt class="descclassname">ca.</tt><tt class="descname">get_precision</tt><big>(</big><em>chid</em><big>)</big><a class="headerlink" href="#ca.get_precision" title="Permalink to this definition">¶</a></dt>
<dd><p>return the precision of a channel.  For channels with native type other
than FLOAT or DOUBLE, this will be 0.</p>
</dd></dl>

<dl class="function">
<dt id="ca.get_enum_strings">
<tt class="descclassname">ca.</tt><tt class="descname">get_enum_strings</tt><big>(</big><em>chid</em><big>)</big><a class="headerlink" href="#ca.get_enum_strings" title="Permalink to this definition">¶</a></dt>
<dd><p>return the list of names for ENUM states of a Channel.  Returns  <tt class="xref docutils literal"><span class="pre">None</span></tt>
for non-ENUM Channels.</p>
</dd></dl>

<dl class="function">
<dt id="ca.get_ctrlvars">
<tt class="descclassname">ca.</tt><tt class="descname">get_ctrlvars</tt><big>(</big><em>chid</em><big>)</big><a class="headerlink" href="#ca.get_ctrlvars" title="Permalink to this definition">¶</a></dt>
<dd><p>returns a dictionary of CTRL fields for a Channel.  Depending on the
native data type, the keys in this dictionary may include
<a class="reference internal" href="#ctrlvars-table"><em>Table of Control Attributes</em></a></p>
</dd></dl>

<blockquote id="ctrlvars-table">
<div><p>Table of Control Attributes</p>
<blockquote>
<div><table border="1" class="docutils">
<colgroup>
<col width="40%" />
<col width="60%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head"><em>attribute</em></th>
<th class="head"><em>data types</em></th>
</tr>
</thead>
<tbody valign="top">
<tr><td>status</td>
<td>&nbsp;</td>
</tr>
<tr><td>severity</td>
<td>&nbsp;</td>
</tr>
<tr><td>precision</td>
<td>0 for all but double, float</td>
</tr>
<tr><td>units</td>
<td>&nbsp;</td>
</tr>
<tr><td>enum_strs</td>
<td>enum only</td>
</tr>
<tr><td>upper_disp_limit</td>
<td>&nbsp;</td>
</tr>
<tr><td>lower_disp_limit</td>
<td>&nbsp;</td>
</tr>
<tr><td>upper_alarm_limit</td>
<td>&nbsp;</td>
</tr>
<tr><td>lower_alarm_limit</td>
<td>&nbsp;</td>
</tr>
<tr><td>upper_warning_limit</td>
<td>&nbsp;</td>
</tr>
<tr><td>lower_warning_limit</td>
<td>&nbsp;</td>
</tr>
<tr><td>upper_ctrl_limit</td>
<td>&nbsp;</td>
</tr>
<tr><td>lower_ctrl_limit</td>
<td>&nbsp;</td>
</tr>
</tbody>
</table>
</div></blockquote>
</div></blockquote>
<p>Note that <em>enum_strs</em> will be a tuple of strings for the names of ENUM
states.</p>
<dl class="function">
<dt id="ca.get_timevars">
<tt class="descclassname">ca.</tt><tt class="descname">get_timevars</tt><big>(</big><em>chid</em><big>)</big><a class="headerlink" href="#ca.get_timevars" title="Permalink to this definition">¶</a></dt>
<dd><p>returns a dictionary of TIME fields for a Channel.  This will contain a
<em>status</em>, <em>severity</em>, and <em>timestamp</em> key.</p>
</dd></dl>

</div>
<div class="section" id="synchronous-groups">
<span id="ca-sg-label"></span><h3>Synchronous Groups<a class="headerlink" href="#synchronous-groups" title="Permalink to this headline">¶</a></h3>
<p>Synchronous Groups can be used to ensure that a set of Channel Access calls
all happen together, as if in a <em>transaction</em>.  Synchronous Groups work in
PyEpics as of version 3.0.10, but more testing is probably needed.</p>
<p>The idea is to first create a synchronous group, then add a series of
<a class="reference internal" href="#ca.sg_put" title="ca.sg_put"><tt class="xref py py-func docutils literal"><span class="pre">sg_put()</span></tt></a> and <a class="reference internal" href="#ca.sg_get" title="ca.sg_get"><tt class="xref py py-func docutils literal"><span class="pre">sg_get()</span></tt></a> which do not happen immediately, and
finally block while all the channel access communication is done for the
group as a unit.  It is important to <em>not</em> issue <a class="reference internal" href="#ca.pend_io" title="ca.pend_io"><tt class="xref py py-func docutils literal"><span class="pre">pend_io()</span></tt></a> during the
building of a synchronous group, as this will cause pending <a class="reference internal" href="#ca.sg_put" title="ca.sg_put"><tt class="xref py py-func docutils literal"><span class="pre">sg_put()</span></tt></a>
and <a class="reference internal" href="#ca.sg_get" title="ca.sg_get"><tt class="xref py py-func docutils literal"><span class="pre">sg_get()</span></tt></a> to execute.</p>
<dl class="function">
<dt id="ca.sg_create">
<tt class="descclassname">ca.</tt><tt class="descname">sg_create</tt><big>(</big><big>)</big><a class="headerlink" href="#ca.sg_create" title="Permalink to this definition">¶</a></dt>
<dd><p>create synchronous group.  Returns a <em>group id</em>, <cite>gid</cite>, which is used to
identify this group and is passed to all other synchronous group commands.</p>
</dd></dl>

<dl class="function">
<dt id="ca.sg_delete">
<tt class="descclassname">ca.</tt><tt class="descname">sg_delete</tt><big>(</big><em>gid</em><big>)</big><a class="headerlink" href="#ca.sg_delete" title="Permalink to this definition">¶</a></dt>
<dd><p>delete a synchronous group</p>
</dd></dl>

<dl class="function">
<dt id="ca.sg_block">
<tt class="descclassname">ca.</tt><tt class="descname">sg_block</tt><big>(</big><em>gid</em><span class="optional">[</span>, <em>t=10.0</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#ca.sg_block" title="Permalink to this definition">¶</a></dt>
<dd><p>block for a synchronous group to complete processing</p>
</dd></dl>

<dl class="function">
<dt id="ca.sg_get">
<tt class="descclassname">ca.</tt><tt class="descname">sg_get</tt><big>(</big><em>gid</em>, <em>chid</em><span class="optional">[</span>, <em>ftype=None</em><span class="optional">[</span>, <em>as_string=False</em><span class="optional">[</span>, <em>as_numpy=True</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#ca.sg_get" title="Permalink to this definition">¶</a></dt>
<dd><p>perform a <cite>get</cite> within a synchronous group.</p>
<p>This function will not immediately return the value, of course, but the
address of the underlying data.</p>
<p>After the <a class="reference internal" href="#ca.sg_block" title="ca.sg_block"><tt class="xref py py-func docutils literal"><span class="pre">sg_block()</span></tt></a> has completed, you must use <a class="reference internal" href="#ca._unpack" title="ca._unpack"><tt class="xref py py-func docutils literal"><span class="pre">_unpack()</span></tt></a>
to convert this data address to the actual value(s).</p>
<p>See example below.</p>
</dd></dl>

<dl class="function">
<dt id="ca.sg_put">
<tt class="descclassname">ca.</tt><tt class="descname">sg_put</tt><big>(</big><em>gid</em>, <em>chid</em>, <em>value</em><big>)</big><a class="headerlink" href="#ca.sg_put" title="Permalink to this definition">¶</a></dt>
<dd><p>perform a <cite>put</cite> within a synchronous group.  This <cite>put</cite> cannot wait for
completion.</p>
</dd></dl>

<dl class="function">
<dt id="ca.sg_test">
<tt class="descclassname">ca.</tt><tt class="descname">sg_test</tt><big>(</big><em>gid</em><big>)</big><a class="headerlink" href="#ca.sg_test" title="Permalink to this definition">¶</a></dt>
<dd><p>test whether a synchronous group has completed.</p>
</dd></dl>

<dl class="function">
<dt id="ca.sg_reset">
<tt class="descclassname">ca.</tt><tt class="descname">sg_reset</tt><big>(</big><em>gid</em><big>)</big><a class="headerlink" href="#ca.sg_reset" title="Permalink to this definition">¶</a></dt>
<dd><p>resets a synchronous group</p>
</dd></dl>

<p>An example use of a synchronous group:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">epics</span> <span class="kn">import</span> <span class="n">ca</span>
<span class="kn">import</span> <span class="nn">time</span>

<span class="n">pvs</span> <span class="o">=</span> <span class="p">(</span><span class="s">&#39;X1.VAL&#39;</span><span class="p">,</span> <span class="s">&#39;X2.VAL&#39;</span><span class="p">,</span> <span class="s">&#39;X3.VAL&#39;</span><span class="p">)</span>
<span class="n">chids</span> <span class="o">=</span> <span class="p">[</span><span class="n">ca</span><span class="o">.</span><span class="n">create_channel</span><span class="p">(</span><span class="n">pvname</span><span class="p">)</span> <span class="k">for</span> <span class="n">pvname</span> <span class="ow">in</span> <span class="n">pvs</span><span class="p">]</span>

<span class="k">for</span> <span class="n">chid</span> <span class="ow">in</span> <span class="n">chids</span><span class="p">:</span>
    <span class="n">ca</span><span class="o">.</span><span class="n">connect_channel</span><span class="p">(</span><span class="n">chid</span><span class="p">)</span>
    <span class="n">ca</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">chid</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

<span class="c"># create synchronous group</span>
<span class="n">sg</span> <span class="o">=</span> <span class="n">ca</span><span class="o">.</span><span class="n">sg_create</span><span class="p">()</span>

<span class="c"># get data pointers from ca.sg_get</span>
<span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="n">ca</span><span class="o">.</span><span class="n">sg_get</span><span class="p">(</span><span class="n">sg</span><span class="p">,</span> <span class="n">chid</span><span class="p">)</span> <span class="k">for</span> <span class="n">chid</span> <span class="ow">in</span> <span class="n">chids</span><span class="p">]</span>

<span class="k">print</span> <span class="s">&#39;Now change these PVs for the next 10 seconds&#39;</span>
<span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">10.0</span><span class="p">)</span>

<span class="k">print</span> <span class="s">&#39;will now block for i/o&#39;</span>
<span class="n">ca</span><span class="o">.</span><span class="n">sg_block</span><span class="p">(</span><span class="n">sg</span><span class="p">)</span>
<span class="c">#</span>
<span class="c"># CALL ca._unpack with data points and chid to extract data</span>
<span class="k">for</span> <span class="n">pvname</span><span class="p">,</span> <span class="n">dat</span><span class="p">,</span> <span class="n">chid</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">pvs</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">chids</span><span class="p">):</span>
    <span class="n">val</span> <span class="o">=</span> <span class="n">ca</span><span class="o">.</span><span class="n">_unpack</span><span class="p">(</span><span class="n">dat</span><span class="p">,</span> <span class="n">chid</span><span class="o">=</span><span class="n">chid</span><span class="p">)</span>
    <span class="k">print</span> <span class="s">&quot;</span><span class="si">%s</span><span class="s"> = </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">pvname</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">val</span><span class="p">))</span>

<span class="n">ca</span><span class="o">.</span><span class="n">sg_reset</span><span class="p">(</span><span class="n">sg</span><span class="p">)</span>

<span class="c">#  Now a SG Put</span>
<span class="k">print</span> <span class="s">&#39;OK, now we will put everything back to 0 synchronously&#39;</span>

<span class="k">for</span> <span class="n">chid</span> <span class="ow">in</span> <span class="n">chids</span><span class="p">:</span>
    <span class="n">ca</span><span class="o">.</span><span class="n">sg_put</span><span class="p">(</span><span class="n">sg</span><span class="p">,</span> <span class="n">chid</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>


<span class="k">print</span> <span class="s">&#39;sg_put done, but not blocked / committed. Sleep for 5 seconds &#39;</span>
<span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">5.0</span><span class="p">)</span>
<span class="n">ca</span><span class="o">.</span><span class="n">sg_block</span><span class="p">(</span><span class="n">sg</span><span class="p">)</span>
<span class="k">print</span> <span class="s">&#39;done.&#39;</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="implementation-details">
<span id="ca-implementation-label"></span><h2>Implementation details<a class="headerlink" href="#implementation-details" title="Permalink to this headline">¶</a></h2>
<p>The details given here should mostly be of interest to those looking at the
implementation of the <cite>ca</cite> module, those interested in the internals, or
those looking to translate lower-level C or Python code to this module.</p>
<div class="section" id="dbr-data-types">
<h3>DBR data types<a class="headerlink" href="#dbr-data-types" title="Permalink to this headline">¶</a></h3>
<blockquote id="dbrtype-table">
<div><p>Table of DBR Types</p>
<blockquote>
<div><table border="1" class="docutils">
<colgroup>
<col width="25%" />
<col width="33%" />
<col width="42%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head"><em>CA type</em></th>
<th class="head"><em>integer ftype</em></th>
<th class="head"><em>Python ctypes type</em></th>
</tr>
</thead>
<tbody valign="top">
<tr><td>string</td>
<td>0</td>
<td>string</td>
</tr>
<tr><td>int</td>
<td>1</td>
<td>integer</td>
</tr>
<tr><td>short</td>
<td>1</td>
<td>integer</td>
</tr>
<tr><td>float</td>
<td>2</td>
<td>double</td>
</tr>
<tr><td>enum</td>
<td>3</td>
<td>integer</td>
</tr>
<tr><td>char</td>
<td>4</td>
<td>byte</td>
</tr>
<tr><td>long</td>
<td>5</td>
<td>integer</td>
</tr>
<tr><td>double</td>
<td>6</td>
<td>double</td>
</tr>
<tr><td>time_string</td>
<td>14</td>
<td>&nbsp;</td>
</tr>
<tr><td>time_int</td>
<td>15</td>
<td>&nbsp;</td>
</tr>
<tr><td>time_short</td>
<td>15</td>
<td>&nbsp;</td>
</tr>
<tr><td>time_float</td>
<td>16</td>
<td>&nbsp;</td>
</tr>
<tr><td>time_enum</td>
<td>17</td>
<td>&nbsp;</td>
</tr>
<tr><td>time_char</td>
<td>18</td>
<td>&nbsp;</td>
</tr>
<tr><td>time_long</td>
<td>19</td>
<td>&nbsp;</td>
</tr>
<tr><td>time_double</td>
<td>20</td>
<td>&nbsp;</td>
</tr>
<tr><td>ctrl_string</td>
<td>28</td>
<td>&nbsp;</td>
</tr>
<tr><td>ctrl_int</td>
<td>29</td>
<td>&nbsp;</td>
</tr>
<tr><td>ctrl_short</td>
<td>29</td>
<td>&nbsp;</td>
</tr>
<tr><td>ctrl_float</td>
<td>30</td>
<td>&nbsp;</td>
</tr>
<tr><td>ctrl_enum</td>
<td>31</td>
<td>&nbsp;</td>
</tr>
<tr><td>ctrl_char</td>
<td>32</td>
<td>&nbsp;</td>
</tr>
<tr><td>ctrl_long</td>
<td>33</td>
<td>&nbsp;</td>
</tr>
<tr><td>ctrl_double</td>
<td>34</td>
<td>&nbsp;</td>
</tr>
</tbody>
</table>
</div></blockquote>
</div></blockquote>
</div>
<div class="section" id="pysevchk-and-channelaccessexcepction-checking-ca-return-codes">
<h3><cite>PySEVCHK</cite> and ChannelAccessExcepction: checking CA return codes<a class="headerlink" href="#pysevchk-and-channelaccessexcepction-checking-ca-return-codes" title="Permalink to this headline">¶</a></h3>
<dl class="exception">
<dt id="ca.ChannelAccessException">
<em class="property">exception </em><tt class="descclassname">ca.</tt><tt class="descname">ChannelAccessException</tt><a class="headerlink" href="#ca.ChannelAccessException" title="Permalink to this definition">¶</a></dt>
<dd><p>This exception is raised when the <a class="reference internal" href="#module-ca" title="ca: low-level Channel Access  module."><tt class="xref py py-mod docutils literal"><span class="pre">ca</span></tt></a> module experiences
unexpected behavior and must raise an exception</p>
</dd></dl>

<dl class="function">
<dt id="ca.PySEVCHK">
<tt class="descclassname">ca.</tt><tt class="descname">PySEVCHK</tt><big>(</big><em>func_name</em>, <em>status</em><span class="optional">[</span>, <em>expected=dbr.ECA_NORMAL</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#ca.PySEVCHK" title="Permalink to this definition">¶</a></dt>
<dd><p>This checks the return <em>status</em> returned from a <cite>libca.ca_***</cite> and
raises a <a class="reference internal" href="#ca.ChannelAccessException" title="ca.ChannelAccessException"><tt class="xref py py-exc docutils literal"><span class="pre">ChannelAccessException</span></tt></a> if the value does not match the
<em>expected</em> value.</p>
<p>The message from the exception will include the <em>func_name</em> (name of
the Python function) and the CA message from <tt class="xref py py-mod docutils literal"><span class="pre">message</span></tt>.</p>
</dd></dl>

<dl class="function">
<dt id="ca.withSEVCHK">
<tt class="descclassname">ca.</tt><tt class="descname">withSEVCHK</tt><big>(</big><big>)</big><a class="headerlink" href="#ca.withSEVCHK" title="Permalink to this definition">¶</a></dt>
<dd><p>this decorator handles the common case of running <a class="reference internal" href="#ca.PySEVCHK" title="ca.PySEVCHK"><tt class="xref py py-func docutils literal"><span class="pre">PySEVCHK()</span></tt></a> for
a function whose return value is from a <cite>libca.ca_***</cite> function and
whose return value should be <tt class="docutils literal"><span class="pre">dbr.ECA_NORMAL</span></tt>.</p>
</dd></dl>

</div>
<div class="section" id="function-decorators">
<h3>Function Decorators<a class="headerlink" href="#function-decorators" title="Permalink to this headline">¶</a></h3>
<p>In addition to <a class="reference internal" href="#ca.withSEVCHK" title="ca.withSEVCHK"><tt class="xref py py-func docutils literal"><span class="pre">withSEVCHK()</span></tt></a>, several other decorator functions are
used heavily inside of ca.py or are available for your convenience.</p>
<dl class="function">
<dt id="ca.withCA">
<tt class="descclassname">ca.</tt><tt class="descname">withCA</tt><big>(</big><big>)</big><a class="headerlink" href="#ca.withCA" title="Permalink to this definition">¶</a></dt>
<dd><p>ensures that the CA library is initialized before many CA functions are
called.  This prevents, for example, one creating a channel ID before CA
has been initialized.</p>
</dd></dl>

<dl class="function">
<dt id="ca.withCHID">
<tt class="descclassname">ca.</tt><tt class="descname">withCHID</tt><big>(</big><big>)</big><a class="headerlink" href="#ca.withCHID" title="Permalink to this definition">¶</a></dt>
<dd><p>ensures that CA functions which require a <tt class="docutils literal"><span class="pre">chid</span></tt> as the first argument
actually have a  <tt class="docutils literal"><span class="pre">chid</span></tt> as the first argument.  This is not a highly
robust test (it actually checks for a ctypes.c_long or int) but is
useful enough to catch most errors before they would cause a crash of
the CA library.</p>
</dd></dl>

<dl class="function">
<dt id="ca.withConnectedCHID">
<tt class="descclassname">ca.</tt><tt class="descname">withConnectedCHID</tt><big>(</big><big>)</big><a class="headerlink" href="#ca.withConnectedCHID" title="Permalink to this definition">¶</a></dt>
<dd><p>ensures that the first argument of a function is a connected <tt class="docutils literal"><span class="pre">chid</span></tt>.
This test is (intended to be) robust, and will (try to) make sure a
<tt class="docutils literal"><span class="pre">chid</span></tt> is actually connected before calling the decorated function.</p>
</dd></dl>

<dl class="function">
<dt id="ca.withInitialContext">
<tt class="descclassname">ca.</tt><tt class="descname">withInitialContext</tt><big>(</big><big>)</big><a class="headerlink" href="#ca.withInitialContext" title="Permalink to this definition">¶</a></dt>
<dd><p>ensures that the called function uses the threading context initially defined.
The See <a class="reference internal" href="advanced.html#advanced-threads-label"><em>Using Python Threads</em></a> for further discussion.</p>
</dd></dl>

</div>
<div class="section" id="unpacking-data-from-callbacks">
<h3>Unpacking Data from Callbacks<a class="headerlink" href="#unpacking-data-from-callbacks" title="Permalink to this headline">¶</a></h3>
<p>Throughout the implementation, there are several places where data returned
by the underlying CA library needs to be be converted to Python data.  This
is encapsulated in the <a class="reference internal" href="#ca._unpack" title="ca._unpack"><tt class="xref py py-func docutils literal"><span class="pre">_unpack()</span></tt></a> function.  In general, you will not
have to run this code, but there is one exception:  when using
<a class="reference internal" href="#ca.sg_get" title="ca.sg_get"><tt class="xref py py-func docutils literal"><span class="pre">sg_get()</span></tt></a>, the values returned will have to be unpacked with this
function.</p>
<dl class="function">
<dt id="ca._unpack">
<tt class="descclassname">ca.</tt><tt class="descname">_unpack</tt><big>(</big><em>cdata</em>, <em>chid=None</em><span class="optional">[</span>, <em>count=None</em><span class="optional">[</span>, <em>ftype=None</em><span class="optional">[</span>, <em>as_numpy=None</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#ca._unpack" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div>This takes the ctypes data <cite>cdata</cite> and returns the Python data.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>cdata</strong> -- cdata as returned by internal libca functions, and <a class="reference internal" href="#ca.sg_get" title="ca.sg_get"><tt class="xref py py-func docutils literal"><span class="pre">sg_get()</span></tt></a>.</li>
<li><strong>chid</strong> -- channel ID (optional: used for determining count and ftype)</li>
<li><strong>count</strong> -- number of elements to fetch (defaults to element count of chid  or 1)</li>
<li><strong>ftype</strong> -- data type of channel (defaults to native type of chid)</li>
<li><strong>as_numpy</strong> (<tt class="xref docutils literal"><span class="pre">True</span></tt>/<tt class="xref docutils literal"><span class="pre">False</span></tt>) -- whether to convert to numpy array.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>
<div class="section" id="user-supplied-callback-functions">
<span id="ca-callbacks-label"></span><h2>User-supplied Callback functions<a class="headerlink" href="#user-supplied-callback-functions" title="Permalink to this headline">¶</a></h2>
<p>User-supplied callback functions can be provided for both <a class="reference internal" href="#ca.put" title="ca.put"><tt class="xref py py-meth docutils literal"><span class="pre">put()</span></tt></a> and
<a class="reference internal" href="#ca.create_subscription" title="ca.create_subscription"><tt class="xref py py-meth docutils literal"><span class="pre">create_subscription()</span></tt></a>.  Note that callbacks for <cite>PV</cite> objects are
slightly different: see <a class="reference internal" href="pv.html#pv-callbacks-label"><em>User-supplied Callback functions</em></a> in the <a class="reference internal" href="pv.html#module-pv" title="pv: PV objects for Epics Channel Access"><tt class="xref py py-mod docutils literal"><span class="pre">pv</span></tt></a> module
for details.</p>
<p>When defining a callback function to be run either when a <a class="reference internal" href="#ca.put" title="ca.put"><tt class="xref py py-meth docutils literal"><span class="pre">put()</span></tt></a>
completes or on changes to the Channel, as set from
<a class="reference internal" href="#ca.create_subscription" title="ca.create_subscription"><tt class="xref py py-meth docutils literal"><span class="pre">create_subscription()</span></tt></a>, it is important to know two things:</p>
<blockquote>
<div><ol class="arabic simple">
<li>how your function will be called.</li>
<li>what is permissible to do inside your callback function.</li>
</ol>
</div></blockquote>
<p>In both cases, callbacks will be called with keyword arguments.  You should be
prepared to have them passed to your function.  Use <cite>**kw</cite> unless you are very
sure of what will be sent.</p>
<p>For callbacks sent when a <a class="reference internal" href="#ca.put" title="ca.put"><tt class="xref py py-meth docutils literal"><span class="pre">put()</span></tt></a> completes, your function will be passed these:</p>
<blockquote>
<div><ul class="simple">
<li><cite>pvname</cite> : the name of the pv</li>
<li><cite>data</cite>:  the user-supplied callback_data (defaulting to <tt class="xref docutils literal"><span class="pre">None</span></tt>).</li>
</ul>
</div></blockquote>
<p>For subscription callbacks, your function will be called with keyword/value
pairs that will include:</p>
<blockquote>
<div><ul class="simple">
<li><cite>pvname</cite>: the name of the pv</li>
<li><cite>value</cite>: the latest value</li>
<li><cite>count</cite>: the number of data elements</li>
<li><cite>ftype</cite>: the numerical CA type indicating the data type</li>
<li><cite>status</cite>: the status of the PV (1 for OK)</li>
<li><cite>chid</cite>:   the integer address for the channel ID.</li>
</ul>
</div></blockquote>
<p>Depending on the data type, and whether the CTRL or TIME variant was used,
the callback function may also include some of these as keyword arguments:</p>
<blockquote>
<div><ul class="simple">
<li><cite>enum_strs</cite>: the list of enumeration strings</li>
<li><cite>precision</cite>: number of decimal places of precision.</li>
<li><cite>units</cite>:  string for PV units</li>
<li><cite>severity</cite>: PV severity</li>
<li><cite>timestamp</cite>: timestamp from CA server.</li>
</ul>
</div></blockquote>
<p>Note that a the user-supplied callback will be run <em>inside</em> a CA function,
and cannot reliably make any other CA calls.  It is helpful to think &quot;this
all happens inside of a <a class="reference internal" href="#ca.pend_event" title="ca.pend_event"><tt class="xref py py-func docutils literal"><span class="pre">pend_event()</span></tt></a> call&quot;, and in an epics thread
that may or may not be the main thread of your program.  It is advisable to
keep the callback functions short and not resource-intensive.  Consider
strategies which use the callback only to record that a change has occurred
and then act on that change later -- perhaps in a separate thread, perhaps
after <a class="reference internal" href="#ca.pend_event" title="ca.pend_event"><tt class="xref py py-func docutils literal"><span class="pre">pend_event()</span></tt></a> has completed.</p>
</div>
<div class="section" id="omissions">
<span id="ca-omissions-label"></span><h2>Omissions<a class="headerlink" href="#omissions" title="Permalink to this headline">¶</a></h2>
<p>Several parts of the CA library are not implemented in the Python module.
These are currently seen as unneeded (with notes where appropriate for
alternatives), though they could be added on request.</p>
<dl class="function">
<dt id="ca.ca_add_exception_event">
<tt class="descclassname">ca.</tt><tt class="descname">ca_add_exception_event</tt><big>(</big><big>)</big><a class="headerlink" href="#ca.ca_add_exception_event" title="Permalink to this definition">¶</a></dt>
<dd><p><em>Not implemented</em>: Python exceptions are raised where appropriate and
can be used in user code.</p>
</dd></dl>

<dl class="function">
<dt id="ca.ca_add_fd_registration">
<tt class="descclassname">ca.</tt><tt class="descname">ca_add_fd_registration</tt><big>(</big><big>)</big><a class="headerlink" href="#ca.ca_add_fd_registration" title="Permalink to this definition">¶</a></dt>
<dd><p><em>Not implemented</em></p>
</dd></dl>

<dl class="function">
<dt id="ca.ca_replace_access_rights_event">
<tt class="descclassname">ca.</tt><tt class="descname">ca_replace_access_rights_event</tt><big>(</big><big>)</big><a class="headerlink" href="#ca.ca_replace_access_rights_event" title="Permalink to this definition">¶</a></dt>
<dd><p><em>Not implemented</em></p>
</dd></dl>

<dl class="function">
<dt id="ca.ca_client_status">
<tt class="descclassname">ca.</tt><tt class="descname">ca_client_status</tt><big>(</big><big>)</big><a class="headerlink" href="#ca.ca_client_status" title="Permalink to this definition">¶</a></dt>
<dd><p><em>Not implemented</em></p>
</dd></dl>

<dl class="function">
<dt id="ca.ca_set_puser">
<tt class="descclassname">ca.</tt><tt class="descname">ca_set_puser</tt><big>(</big><big>)</big><a class="headerlink" href="#ca.ca_set_puser" title="Permalink to this definition">¶</a></dt>
<dd><p><em>Not implemented</em> : it is easy to pass user-defined data to callbacks as needed.</p>
</dd></dl>

<dl class="function">
<dt id="ca.ca_puser">
<tt class="descclassname">ca.</tt><tt class="descname">ca_puser</tt><big>(</big><big>)</big><a class="headerlink" href="#ca.ca_puser" title="Permalink to this definition">¶</a></dt>
<dd><p><em>Not implemented</em>: it is easy to pass user-defined data to callbacks as needed.</p>
</dd></dl>

<dl class="function">
<dt id="ca.ca_SEVCHK">
<tt class="descclassname">ca.</tt><tt class="descname">ca_SEVCHK</tt><big>(</big><big>)</big><a class="headerlink" href="#ca.ca_SEVCHK" title="Permalink to this definition">¶</a></dt>
<dd><p><em>Not implemented</em>: the Python function <a class="reference internal" href="#ca.PySEVCHK" title="ca.PySEVCHK"><tt class="xref py py-func docutils literal"><span class="pre">PySEVCHK()</span></tt></a> is
approximately the same.</p>
</dd></dl>

<dl class="function">
<dt id="ca.ca_signal">
<tt class="descclassname">ca.</tt><tt class="descname">ca_signal</tt><big>(</big><big>)</big><a class="headerlink" href="#ca.ca_signal" title="Permalink to this definition">¶</a></dt>
<dd><p><em>Not implemented</em>: the Python function <a class="reference internal" href="#ca.PySEVCHK" title="ca.PySEVCHK"><tt class="xref py py-func docutils literal"><span class="pre">PySEVCHK()</span></tt></a> is
approximately the same.</p>
</dd></dl>

<dl class="function">
<dt id="ca.ca_test_event">
<tt class="descclassname">ca.</tt><tt class="descname">ca_test_event</tt><big>(</big><big>)</big><a class="headerlink" href="#ca.ca_test_event" title="Permalink to this definition">¶</a></dt>
<dd><p><em>Not implemented</em>:  this appears to be a function for debugging events.
These are easy enough to simulate by directly calling Python callback
functions.</p>
</dd></dl>

<dl class="function">
<dt id="ca.ca_dump_dbr">
<tt class="descclassname">ca.</tt><tt class="descname">ca_dump_dbr</tt><big>(</big><big>)</big><a class="headerlink" href="#ca.ca_dump_dbr" title="Permalink to this definition">¶</a></dt>
<dd><p><em>Not implemented</em></p>
</dd></dl>

<p>In addition, not all <cite>DBR</cite> types in the CA C library are supported.</p>
<p>Only native types and their DBR_TIME and DBR_CTRL variants are supported:
DBR_STS and DBR_GR variants are not. Several <cite>dbr_XXX</cite> functions are also
not supported, as they are needed only to dynamically allocate memory.</p>
</div>
<div class="section" id="cathread-class">
<h2><a class="reference internal" href="#ca.CAThread" title="ca.CAThread"><tt class="xref py py-class docutils literal"><span class="pre">CAThread</span></tt></a> class<a class="headerlink" href="#cathread-class" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="ca.CAThread">
<em class="property">class </em><tt class="descclassname">ca.</tt><tt class="descname">CAThread</tt><big>(</big><em>group=None</em><span class="optional">[</span>, <em>target=None</em><span class="optional">[</span>, <em>name=None</em><span class="optional">[</span>, <em>args=()</em><span class="optional">[</span>, <em>kwargs={}</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><big>)</big><a class="headerlink" href="#ca.CAThread" title="Permalink to this definition">¶</a></dt>
<dd><p>create a CA-aware subclass of a standard Python <tt class="xref py py-class docutils literal"><span class="pre">threading.Thread</span></tt>.  See the
standard library documentation for further information on how to use Thread objects.</p>
<p>A <cite>CAThread</cite> simply runs <a class="reference internal" href="#ca.use_initial_context" title="ca.use_initial_context"><tt class="xref py py-func docutils literal"><span class="pre">use_initial_context()</span></tt></a> prior to running each target
function, so that <a class="reference internal" href="#ca.use_initial_context" title="ca.use_initial_context"><tt class="xref py py-func docutils literal"><span class="pre">use_initial_context()</span></tt></a> does not have to be explicitly put inside
the target function.</p>
<p>The See <a class="reference internal" href="advanced.html#advanced-threads-label"><em>Using Python Threads</em></a> for further discussion.</p>
</dd></dl>

</div>
<div class="section" id="examples">
<h2>Examples<a class="headerlink" href="#examples" title="Permalink to this headline">¶</a></h2>
<p>Here are some example sessions using the <a class="reference internal" href="#module-ca" title="ca: low-level Channel Access  module."><tt class="xref py py-mod docutils literal"><span class="pre">ca</span></tt></a> module.</p>
<div class="section" id="create-connect-get-value-of-channel">
<h3>Create, Connect, Get Value of Channel<a class="headerlink" href="#create-connect-get-value-of-channel" title="Permalink to this headline">¶</a></h3>
<p>Note here that several things have been simplified compare to using CA in C:
initialization and creating a main-thread context are handled, and connection
of channels is handled in the background:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">epics</span> <span class="kn">import</span> <span class="n">ca</span>
<span class="n">chid</span>  <span class="o">=</span> <span class="n">ca</span><span class="o">.</span><span class="n">create_channel</span><span class="p">(</span><span class="s">&#39;XXX:m1.VAL&#39;</span><span class="p">)</span>
<span class="n">count</span> <span class="o">=</span> <span class="n">ca</span><span class="o">.</span><span class="n">element_count</span><span class="p">(</span><span class="n">chid</span><span class="p">)</span>
<span class="n">ftype</span> <span class="o">=</span> <span class="n">ca</span><span class="o">.</span><span class="n">field_type</span><span class="p">(</span><span class="n">chid</span><span class="p">)</span>
<span class="k">print</span> <span class="s">&quot;Channel &quot;</span><span class="p">,</span> <span class="n">chid</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">ftype</span>
<span class="n">value</span> <span class="o">=</span> <span class="n">ca</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
<span class="k">print</span> <span class="n">value</span>
</pre></div>
</div>
</div>
<div class="section" id="put-waiting-for-completion">
<h3>Put, waiting for completion<a class="headerlink" href="#put-waiting-for-completion" title="Permalink to this headline">¶</a></h3>
<p>Here we set a PVs value, waiting for it to complete:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">epics</span> <span class="kn">import</span> <span class="n">ca</span>
<span class="n">chid</span>  <span class="o">=</span> <span class="n">ca</span><span class="o">.</span><span class="n">create_channel</span><span class="p">(</span><span class="s">&#39;XXX:m1.VAL&#39;</span><span class="p">)</span>
<span class="n">ca</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">chid</span><span class="p">,</span>  <span class="mf">1.0</span><span class="p">,</span> <span class="n">wait</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
<p>The  <a class="reference internal" href="#ca.put" title="ca.put"><tt class="xref py py-meth docutils literal"><span class="pre">put()</span></tt></a> method will wait to return until the processing is
complete.</p>
</div>
<div class="section" id="define-a-callback-to-subscribe-to-changes">
<h3>Define a callback to Subscribe to Changes<a class="headerlink" href="#define-a-callback-to-subscribe-to-changes" title="Permalink to this headline">¶</a></h3>
<p>Here, we <em>subscribe to changes</em> for a PV, which is to say we define a
callback function to be called whenever the PV value changes.   In the case
below, the function to be called will simply write the latest value out to
standard output:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">epics</span> <span class="kn">import</span> <span class="n">ca</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">sys</span>

<span class="c"># define a callback function.  Note that this should</span>
<span class="c"># expect certain keyword arguments, including &#39;pvname&#39; and &#39;value&#39;</span>
<span class="k">def</span> <span class="nf">onChanges</span><span class="p">(</span><span class="n">pvname</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
    <span class="n">fmt</span> <span class="o">=</span> <span class="s">&#39;New Value: </span><span class="si">%s</span><span class="s">  value=</span><span class="si">%s</span><span class="s">, kw=</span><span class="si">%s</span><span class="se">\n</span><span class="s">&#39;</span>
    <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">fmt</span> <span class="o">%</span> <span class="p">(</span><span class="n">pvname</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">value</span><span class="p">),</span> <span class="nb">repr</span><span class="p">(</span><span class="n">kw</span><span class="p">)))</span>
    <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>

<span class="c"># create the channel</span>
<span class="n">mypv</span> <span class="o">=</span> <span class="s">&#39;XXX.VAL&#39;</span>
<span class="n">chid</span> <span class="o">=</span> <span class="n">ca</span><span class="o">.</span><span class="n">create_channel</span><span class="p">(</span><span class="n">mypv</span><span class="p">)</span>

<span class="c"># subscribe to events giving a callback function</span>
<span class="n">eventID</span> <span class="o">=</span> <span class="n">ca</span><span class="o">.</span><span class="n">create_subscription</span><span class="p">(</span><span class="n">chid</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="n">onChanges</span><span class="p">)</span>

<span class="c"># now we simply wait for changes</span>
<span class="n">t0</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
<span class="k">while</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">t0</span> <span class="o">&lt;</span> <span class="mf">10.0</span><span class="p">:</span>
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.001</span><span class="p">)</span>
</pre></div>
</div>
<p>It is <strong>vital</strong> that the return value from <a class="reference internal" href="#ca.create_subscription" title="ca.create_subscription"><tt class="xref py py-meth docutils literal"><span class="pre">create_subscription()</span></tt></a> is
kept in a variable so that it cannot be garbage collected.  Failure to keep
this value will cause trouble, including almost immediate segmentation
faults (on Windows) or seemingly inexplicable crashes later (on linux).</p>
</div>
<div class="section" id="define-a-connection-callback">
<h3>Define a connection callback<a class="headerlink" href="#define-a-connection-callback" title="Permalink to this headline">¶</a></h3>
<p>Here, we define a connection callback -- a function to be called when the
connection status of the PV changes. Note that this will be called on
initial connection:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">epics</span>
<span class="kn">import</span> <span class="nn">time</span>

<span class="k">def</span> <span class="nf">onConnectionChange</span><span class="p">(</span><span class="n">pvname</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">conn</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">chid</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="k">print</span> <span class="s">&#39;ca connection status changed:  &#39;</span><span class="p">,</span> <span class="n">pvname</span><span class="p">,</span>  <span class="n">conn</span><span class="p">,</span> <span class="n">chid</span>

<span class="c"># create channel, provide connection callback</span>
<span class="n">motor1</span> <span class="o">=</span> <span class="s">&#39;13IDC:m1&#39;</span>
<span class="n">chid</span> <span class="o">=</span> <span class="n">epics</span><span class="o">.</span><span class="n">ca</span><span class="o">.</span><span class="n">create_channel</span><span class="p">(</span><span class="n">motor1</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="n">onConnectionChange</span><span class="p">)</span>

<span class="k">print</span> <span class="s">&#39;Now waiting, watching values and connection changes:&#39;</span>
<span class="n">t0</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
<span class="k">while</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">t0</span> <span class="o">&lt;</span> <span class="mi">30</span><span class="p">:</span>
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.001</span><span class="p">)</span>
</pre></div>
</div>
<p>This will run the supplied callback soon after the channel has been
created, when a successful connection has been made.  Note that the
callback should be prepared to accept keyword arguments of <cite>pvname</cite>,
<cite>chid</cite>, and <cite>conn</cite> for the PV name, channel ID, and connection state
(<tt class="xref docutils literal"><span class="pre">True</span></tt> or <tt class="xref docutils literal"><span class="pre">False</span></tt>).</p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="advanced.html" title="Advanced Topic with Python Channel Access"
             >next</a> |</li>
        <li class="right" >
          <a href="pv.html" title="The Epics PV class"
             >previous</a> |</li>
   <li><a href="overview.html">getting started</a>|&nbsp;</li>
   <li><a href="installation.html">download</a>|&nbsp;</li>
   <li><a href="pv.html">PVs</a>|&nbsp;</li>
   <li><a href="devices.html">Devices</a>|&nbsp;</li>
   <li><a href="wx.html">wxWidgets</a>|&nbsp;</li>
   <li><a href="more.html">More...</a>|&nbsp;</li>
   &nbsp;&nbsp;<li><a href="search.html">search</a>&nbsp;</li>
 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2010, Matthew Newville.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.0.7.
    </div>
  </body>
</html>